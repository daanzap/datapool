#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Apr 22 11:22:16 2015 by generateDS.py version 2.15b.
#
# Command line options:
#   ('-o', 'iati.py')
#   ('-s', 'iati_sub.py')
#
# Command line arguments:
#   iati-activities-schema.xsd
#
# Command line:
#   /home/daan/.virtualenvs/datapool/bin/generateDS.py -o "iati.py" -s "iati_sub.py" iati-activities-schema.xsd
#
# Current working directory (os.getcwd()):
#   genDS
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True


def parsexml_(*args, **kwargs):
    if 'parser' not in kwargs:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class iati_activities(GeneratedsSuper):
    """Top-level list of one or more IATI activity records. A number
    indicating the IATI specification version in use. This is
    mandatory and must be a valid version. A date/time stamp for
    when this file was generated. This is not necessarily the last-
    updated date for the individual activity records in it. Use of
    this attribute is highly recommended, to allow recipients to
    know when a file has been updated. If a publisher chooses to
    publish linked data about their IATI activities then allowing
    them to declare where this data is published would support
    discovery of it, and any additional information they may choose
    to publish as Linked Data alongside it. This attribute is a URI
    path upon which an activity identifier can be appended to get a
    dereferenceable URI for any activity contained within a file.
    Where a publisher declares using one of these properties that
    authoritative linked data is accessible for an activity then
    consuming applications that are generating Linked Data from an
    IATI XML file should assert an owl:sameAs relationship to the
    relevant URI."""
    subclass = None
    superclass = None
    def __init__(self, generated_datetime=None, version=None, linked_data_default=None, iati_activity=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if isinstance(generated_datetime, basestring):
            initvalue_ = datetime_.datetime.strptime(generated_datetime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = generated_datetime
        self.generated_datetime = initvalue_
        self.version = _cast(None, version)
        self.linked_data_default = _cast(None, linked_data_default)
        if iati_activity is None:
            self.iati_activity = []
        else:
            self.iati_activity = iati_activity
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if iati_activities.subclass:
            return iati_activities.subclass(*args_, **kwargs_)
        else:
            return iati_activities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_iati_activity(self): return self.iati_activity
    def set_iati_activity(self, iati_activity): self.iati_activity = iati_activity
    def add_iati_activity(self, value): self.iati_activity.append(value)
    def insert_iati_activity_at(self, index, value): self.iati_activity.insert(index, value)
    def replace_iati_activity_at(self, index, value): self.iati_activity[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_generated_datetime(self): return self.generated_datetime
    def set_generated_datetime(self, generated_datetime): self.generated_datetime = generated_datetime
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_linked_data_default(self): return self.linked_data_default
    def set_linked_data_default(self, linked_data_default): self.linked_data_default = linked_data_default
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.iati_activity or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='iati-activities', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='iati-activities')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='iati-activities', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='iati-activities'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.generated_datetime is not None and 'generated_datetime' not in already_processed:
            already_processed.add('generated_datetime')
            outfile.write(' generated-datetime="%s"' % self.gds_format_datetime(self.generated_datetime, input_name='generated-datetime'))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.linked_data_default is not None and 'linked_data_default' not in already_processed:
            already_processed.add('linked_data_default')
            outfile.write(' linked-data-default=%s' % (self.gds_format_string(quote_attrib(self.linked_data_default).encode(ExternalEncoding), input_name='linked-data-default'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='iati-activities', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for iati_activity_ in self.iati_activity:
            iati_activity_.export(outfile, level, namespace_, name_='iati-activity', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='iati-activities'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.generated_datetime is not None and 'generated_datetime' not in already_processed:
            already_processed.add('generated_datetime')
            showIndent(outfile, level)
            outfile.write('generated-datetime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.generated_datetime, input_name='generated-datetime'))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.linked_data_default is not None and 'linked_data_default' not in already_processed:
            already_processed.add('linked_data_default')
            showIndent(outfile, level)
            outfile.write('linked_data_default="%s",\n' % (self.linked_data_default,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('iati_activity=[\n')
        level += 1
        for iati_activity_ in self.iati_activity:
            showIndent(outfile, level)
            outfile.write('model_.iati_activity(\n')
            iati_activity_.exportLiteral(outfile, level, name_='iati-activity')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('generated-datetime', node)
        if value is not None and 'generated-datetime' not in already_processed:
            already_processed.add('generated-datetime')
            try:
                self.generated_datetime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (generated-datetime): %s' % exp)
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('linked-data-default', node)
        if value is not None and 'linked-data-default' not in already_processed:
            already_processed.add('linked-data-default')
            self.linked_data_default = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'iati-activity':
            obj_ = iati_activity.factory()
            obj_.build(child_)
            self.iati_activity.append(obj_)
            obj_.original_tagname_ = 'iati-activity'
        else:
            obj_ = self.gds_build_any(child_, 'iati-activities')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class iati_activities


class iati_activity(GeneratedsSuper):
    """Top-level element for a single IATI activity report. The last
    date/time that the data for this specific activity was updated.
    This date must change whenever the value of any field changes.
    ISO 639-1 code specifying the default language used in narrative
    elements throughout the activity. If this is not declared then
    the xml:lang attribute MUST be specified for each narrative
    element. Default ISO 4217 alphabetic currency code for all
    financial values in this activity report. If this is not
    declared then the currency attribute MUST be specified for all
    monetary values. The hierarchical level within the reporting
    organisation's subdivision of its units of aid. (eg activity =
    1; sub-activity = 2; sub-sub-activity = 3). If hierarchy is not
    reported then 1 is assumed. If multiple levels are reported
    then, to avoid double counting, financial transactions should
    only be reported at the lowest hierarchical level. A Linked Data
    URI for a given activity (overrides iati-activities/@linked-
    data-default if set)"""
    subclass = None
    superclass = None
    def __init__(self, lang=None, last_updated_datetime=None, linked_data_uri=None, hierarchy=None, default_currency=None, iati_identifier=None, reporting_org=None, title=None, description=None, participating_org=None, other_identifier=None, activity_status=None, activity_date=None, contact_info=None, activity_scope=None, recipient_country=None, recipient_region=None, location=None, sector=None, country_budget_items=None, policy_marker=None, collaboration_type=None, default_flow_type=None, default_finance_type=None, default_aid_type=None, default_tied_status=None, budget=None, planned_disbursement=None, capital_spend=None, transaction=None, document_link=None, related_activity=None, legacy_data=None, conditions=None, result=None, crs_add=None, fss=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.lang = _cast(None, lang)
        if isinstance(last_updated_datetime, basestring):
            initvalue_ = datetime_.datetime.strptime(last_updated_datetime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = last_updated_datetime
        self.last_updated_datetime = initvalue_
        self.linked_data_uri = _cast(None, linked_data_uri)
        self.hierarchy = _cast(int, hierarchy)
        self.default_currency = _cast(None, default_currency)
        self.iati_identifier = iati_identifier
        self.reporting_org = reporting_org
        self.title = title
        if description is None:
            self.description = []
        else:
            self.description = description
        if participating_org is None:
            self.participating_org = []
        else:
            self.participating_org = participating_org
        if other_identifier is None:
            self.other_identifier = []
        else:
            self.other_identifier = other_identifier
        self.activity_status = activity_status
        if activity_date is None:
            self.activity_date = []
        else:
            self.activity_date = activity_date
        if contact_info is None:
            self.contact_info = []
        else:
            self.contact_info = contact_info
        self.activity_scope = activity_scope
        if recipient_country is None:
            self.recipient_country = []
        else:
            self.recipient_country = recipient_country
        if recipient_region is None:
            self.recipient_region = []
        else:
            self.recipient_region = recipient_region
        if location is None:
            self.location = []
        else:
            self.location = location
        if sector is None:
            self.sector = []
        else:
            self.sector = sector
        self.country_budget_items = country_budget_items
        if policy_marker is None:
            self.policy_marker = []
        else:
            self.policy_marker = policy_marker
        self.collaboration_type = collaboration_type
        self.default_flow_type = default_flow_type
        self.default_finance_type = default_finance_type
        self.default_aid_type = default_aid_type
        self.default_tied_status = default_tied_status
        if budget is None:
            self.budget = []
        else:
            self.budget = budget
        if planned_disbursement is None:
            self.planned_disbursement = []
        else:
            self.planned_disbursement = planned_disbursement
        self.capital_spend = capital_spend
        if transaction is None:
            self.transaction = []
        else:
            self.transaction = transaction
        if document_link is None:
            self.document_link = []
        else:
            self.document_link = document_link
        if related_activity is None:
            self.related_activity = []
        else:
            self.related_activity = related_activity
        if legacy_data is None:
            self.legacy_data = []
        else:
            self.legacy_data = legacy_data
        self.conditions = conditions
        if result is None:
            self.result = []
        else:
            self.result = result
        self.crs_add = crs_add
        self.fss = fss
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if iati_activity.subclass:
            return iati_activity.subclass(*args_, **kwargs_)
        else:
            return iati_activity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_iati_identifier(self): return self.iati_identifier
    def set_iati_identifier(self, iati_identifier): self.iati_identifier = iati_identifier
    def get_reporting_org(self): return self.reporting_org
    def set_reporting_org(self, reporting_org): self.reporting_org = reporting_org
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description_at(self, index, value): self.description.insert(index, value)
    def replace_description_at(self, index, value): self.description[index] = value
    def get_participating_org(self): return self.participating_org
    def set_participating_org(self, participating_org): self.participating_org = participating_org
    def add_participating_org(self, value): self.participating_org.append(value)
    def insert_participating_org_at(self, index, value): self.participating_org.insert(index, value)
    def replace_participating_org_at(self, index, value): self.participating_org[index] = value
    def get_other_identifier(self): return self.other_identifier
    def set_other_identifier(self, other_identifier): self.other_identifier = other_identifier
    def add_other_identifier(self, value): self.other_identifier.append(value)
    def insert_other_identifier_at(self, index, value): self.other_identifier.insert(index, value)
    def replace_other_identifier_at(self, index, value): self.other_identifier[index] = value
    def get_activity_status(self): return self.activity_status
    def set_activity_status(self, activity_status): self.activity_status = activity_status
    def get_activity_date(self): return self.activity_date
    def set_activity_date(self, activity_date): self.activity_date = activity_date
    def add_activity_date(self, value): self.activity_date.append(value)
    def insert_activity_date_at(self, index, value): self.activity_date.insert(index, value)
    def replace_activity_date_at(self, index, value): self.activity_date[index] = value
    def get_contact_info(self): return self.contact_info
    def set_contact_info(self, contact_info): self.contact_info = contact_info
    def add_contact_info(self, value): self.contact_info.append(value)
    def insert_contact_info_at(self, index, value): self.contact_info.insert(index, value)
    def replace_contact_info_at(self, index, value): self.contact_info[index] = value
    def get_activity_scope(self): return self.activity_scope
    def set_activity_scope(self, activity_scope): self.activity_scope = activity_scope
    def get_recipient_country(self): return self.recipient_country
    def set_recipient_country(self, recipient_country): self.recipient_country = recipient_country
    def add_recipient_country(self, value): self.recipient_country.append(value)
    def insert_recipient_country_at(self, index, value): self.recipient_country.insert(index, value)
    def replace_recipient_country_at(self, index, value): self.recipient_country[index] = value
    def get_recipient_region(self): return self.recipient_region
    def set_recipient_region(self, recipient_region): self.recipient_region = recipient_region
    def add_recipient_region(self, value): self.recipient_region.append(value)
    def insert_recipient_region_at(self, index, value): self.recipient_region.insert(index, value)
    def replace_recipient_region_at(self, index, value): self.recipient_region[index] = value
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def add_location(self, value): self.location.append(value)
    def insert_location_at(self, index, value): self.location.insert(index, value)
    def replace_location_at(self, index, value): self.location[index] = value
    def get_sector(self): return self.sector
    def set_sector(self, sector): self.sector = sector
    def add_sector(self, value): self.sector.append(value)
    def insert_sector_at(self, index, value): self.sector.insert(index, value)
    def replace_sector_at(self, index, value): self.sector[index] = value
    def get_country_budget_items(self): return self.country_budget_items
    def set_country_budget_items(self, country_budget_items): self.country_budget_items = country_budget_items
    def get_policy_marker(self): return self.policy_marker
    def set_policy_marker(self, policy_marker): self.policy_marker = policy_marker
    def add_policy_marker(self, value): self.policy_marker.append(value)
    def insert_policy_marker_at(self, index, value): self.policy_marker.insert(index, value)
    def replace_policy_marker_at(self, index, value): self.policy_marker[index] = value
    def get_collaboration_type(self): return self.collaboration_type
    def set_collaboration_type(self, collaboration_type): self.collaboration_type = collaboration_type
    def get_default_flow_type(self): return self.default_flow_type
    def set_default_flow_type(self, default_flow_type): self.default_flow_type = default_flow_type
    def get_default_finance_type(self): return self.default_finance_type
    def set_default_finance_type(self, default_finance_type): self.default_finance_type = default_finance_type
    def get_default_aid_type(self): return self.default_aid_type
    def set_default_aid_type(self, default_aid_type): self.default_aid_type = default_aid_type
    def get_default_tied_status(self): return self.default_tied_status
    def set_default_tied_status(self, default_tied_status): self.default_tied_status = default_tied_status
    def get_budget(self): return self.budget
    def set_budget(self, budget): self.budget = budget
    def add_budget(self, value): self.budget.append(value)
    def insert_budget_at(self, index, value): self.budget.insert(index, value)
    def replace_budget_at(self, index, value): self.budget[index] = value
    def get_planned_disbursement(self): return self.planned_disbursement
    def set_planned_disbursement(self, planned_disbursement): self.planned_disbursement = planned_disbursement
    def add_planned_disbursement(self, value): self.planned_disbursement.append(value)
    def insert_planned_disbursement_at(self, index, value): self.planned_disbursement.insert(index, value)
    def replace_planned_disbursement_at(self, index, value): self.planned_disbursement[index] = value
    def get_capital_spend(self): return self.capital_spend
    def set_capital_spend(self, capital_spend): self.capital_spend = capital_spend
    def get_transaction(self): return self.transaction
    def set_transaction(self, transaction): self.transaction = transaction
    def add_transaction(self, value): self.transaction.append(value)
    def insert_transaction_at(self, index, value): self.transaction.insert(index, value)
    def replace_transaction_at(self, index, value): self.transaction[index] = value
    def get_document_link(self): return self.document_link
    def set_document_link(self, document_link): self.document_link = document_link
    def add_document_link(self, value): self.document_link.append(value)
    def insert_document_link_at(self, index, value): self.document_link.insert(index, value)
    def replace_document_link_at(self, index, value): self.document_link[index] = value
    def get_related_activity(self): return self.related_activity
    def set_related_activity(self, related_activity): self.related_activity = related_activity
    def add_related_activity(self, value): self.related_activity.append(value)
    def insert_related_activity_at(self, index, value): self.related_activity.insert(index, value)
    def replace_related_activity_at(self, index, value): self.related_activity[index] = value
    def get_legacy_data(self): return self.legacy_data
    def set_legacy_data(self, legacy_data): self.legacy_data = legacy_data
    def add_legacy_data(self, value): self.legacy_data.append(value)
    def insert_legacy_data_at(self, index, value): self.legacy_data.insert(index, value)
    def replace_legacy_data_at(self, index, value): self.legacy_data[index] = value
    def get_conditions(self): return self.conditions
    def set_conditions(self, conditions): self.conditions = conditions
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def add_result(self, value): self.result.append(value)
    def insert_result_at(self, index, value): self.result.insert(index, value)
    def replace_result_at(self, index, value): self.result[index] = value
    def get_crs_add(self): return self.crs_add
    def set_crs_add(self, crs_add): self.crs_add = crs_add
    def get_fss(self): return self.fss
    def set_fss(self, fss): self.fss = fss
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_last_updated_datetime(self): return self.last_updated_datetime
    def set_last_updated_datetime(self, last_updated_datetime): self.last_updated_datetime = last_updated_datetime
    def get_linked_data_uri(self): return self.linked_data_uri
    def set_linked_data_uri(self, linked_data_uri): self.linked_data_uri = linked_data_uri
    def get_hierarchy(self): return self.hierarchy
    def set_hierarchy(self, hierarchy): self.hierarchy = hierarchy
    def get_default_currency(self): return self.default_currency
    def set_default_currency(self, default_currency): self.default_currency = default_currency
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.iati_identifier is not None or
            self.reporting_org is not None or
            self.title is not None or
            self.description or
            self.participating_org or
            self.other_identifier or
            self.activity_status is not None or
            self.activity_date or
            self.contact_info or
            self.activity_scope is not None or
            self.recipient_country or
            self.recipient_region or
            self.location or
            self.sector or
            self.country_budget_items is not None or
            self.policy_marker or
            self.collaboration_type is not None or
            self.default_flow_type is not None or
            self.default_finance_type is not None or
            self.default_aid_type is not None or
            self.default_tied_status is not None or
            self.budget or
            self.planned_disbursement or
            self.capital_spend is not None or
            self.transaction or
            self.document_link or
            self.related_activity or
            self.legacy_data or
            self.conditions is not None or
            self.result or
            self.crs_add is not None or
            self.fss is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='iati-activity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='iati-activity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='iati-activity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='iati-activity'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (quote_attrib(self.lang), ))
        if self.last_updated_datetime is not None and 'last_updated_datetime' not in already_processed:
            already_processed.add('last_updated_datetime')
            outfile.write(' last-updated-datetime="%s"' % self.gds_format_datetime(self.last_updated_datetime, input_name='last-updated-datetime'))
        if self.linked_data_uri is not None and 'linked_data_uri' not in already_processed:
            already_processed.add('linked_data_uri')
            outfile.write(' linked-data-uri=%s' % (self.gds_format_string(quote_attrib(self.linked_data_uri).encode(ExternalEncoding), input_name='linked-data-uri'), ))
        if self.hierarchy is not None and 'hierarchy' not in already_processed:
            already_processed.add('hierarchy')
            outfile.write(' hierarchy="%s"' % self.gds_format_integer(self.hierarchy, input_name='hierarchy'))
        if self.default_currency is not None and 'default_currency' not in already_processed:
            already_processed.add('default_currency')
            outfile.write(' default-currency=%s' % (self.gds_format_string(quote_attrib(self.default_currency).encode(ExternalEncoding), input_name='default-currency'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='iati-activity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.iati_identifier is not None:
            self.iati_identifier.export(outfile, level, namespace_, name_='iati-identifier', pretty_print=pretty_print)
        if self.reporting_org is not None:
            self.reporting_org.export(outfile, level, namespace_, name_='reporting-org', pretty_print=pretty_print)
        if self.title is not None:
            self.title.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        for description_ in self.description:
            description_.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
        for participating_org_ in self.participating_org:
            participating_org_.export(outfile, level, namespace_, name_='participating-org', pretty_print=pretty_print)
        for other_identifier_ in self.other_identifier:
            other_identifier_.export(outfile, level, namespace_, name_='other-identifier', pretty_print=pretty_print)
        if self.activity_status is not None:
            self.activity_status.export(outfile, level, namespace_, name_='activity-status', pretty_print=pretty_print)
        for activity_date_ in self.activity_date:
            activity_date_.export(outfile, level, namespace_, name_='activity-date', pretty_print=pretty_print)
        for contact_info_ in self.contact_info:
            contact_info_.export(outfile, level, namespace_, name_='contact-info', pretty_print=pretty_print)
        if self.activity_scope is not None:
            self.activity_scope.export(outfile, level, namespace_, name_='activity-scope', pretty_print=pretty_print)
        for recipient_country_ in self.recipient_country:
            recipient_country_.export(outfile, level, namespace_, name_='recipient-country', pretty_print=pretty_print)
        for recipient_region_ in self.recipient_region:
            recipient_region_.export(outfile, level, namespace_, name_='recipient-region', pretty_print=pretty_print)
        for location_ in self.location:
            location_.export(outfile, level, namespace_, name_='location', pretty_print=pretty_print)
        for sector_ in self.sector:
            sector_.export(outfile, level, namespace_, name_='sector', pretty_print=pretty_print)
        if self.country_budget_items is not None:
            self.country_budget_items.export(outfile, level, namespace_, name_='country-budget-items', pretty_print=pretty_print)
        for policy_marker_ in self.policy_marker:
            policy_marker_.export(outfile, level, namespace_, name_='policy-marker', pretty_print=pretty_print)
        if self.collaboration_type is not None:
            self.collaboration_type.export(outfile, level, namespace_, name_='collaboration-type', pretty_print=pretty_print)
        if self.default_flow_type is not None:
            self.default_flow_type.export(outfile, level, namespace_, name_='default-flow-type', pretty_print=pretty_print)
        if self.default_finance_type is not None:
            self.default_finance_type.export(outfile, level, namespace_, name_='default-finance-type', pretty_print=pretty_print)
        if self.default_aid_type is not None:
            self.default_aid_type.export(outfile, level, namespace_, name_='default-aid-type', pretty_print=pretty_print)
        if self.default_tied_status is not None:
            self.default_tied_status.export(outfile, level, namespace_, name_='default-tied-status', pretty_print=pretty_print)
        for budget_ in self.budget:
            budget_.export(outfile, level, namespace_, name_='budget', pretty_print=pretty_print)
        for planned_disbursement_ in self.planned_disbursement:
            planned_disbursement_.export(outfile, level, namespace_, name_='planned-disbursement', pretty_print=pretty_print)
        if self.capital_spend is not None:
            self.capital_spend.export(outfile, level, namespace_, name_='capital-spend', pretty_print=pretty_print)
        for transaction_ in self.transaction:
            transaction_.export(outfile, level, namespace_, name_='transaction', pretty_print=pretty_print)
        for document_link_ in self.document_link:
            document_link_.export(outfile, level, namespace_, name_='document-link', pretty_print=pretty_print)
        for related_activity_ in self.related_activity:
            related_activity_.export(outfile, level, namespace_, name_='related-activity', pretty_print=pretty_print)
        for legacy_data_ in self.legacy_data:
            legacy_data_.export(outfile, level, namespace_, name_='legacy-data', pretty_print=pretty_print)
        if self.conditions is not None:
            self.conditions.export(outfile, level, namespace_, name_='conditions', pretty_print=pretty_print)
        for result_ in self.result:
            result_.export(outfile, level, namespace_, name_='result', pretty_print=pretty_print)
        if self.crs_add is not None:
            self.crs_add.export(outfile, level, namespace_, name_='crs-add', pretty_print=pretty_print)
        if self.fss is not None:
            self.fss.export(outfile, level, namespace_, name_='fss', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='iati-activity'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang=%s,\n' % (self.lang,))
        if self.last_updated_datetime is not None and 'last_updated_datetime' not in already_processed:
            already_processed.add('last_updated_datetime')
            showIndent(outfile, level)
            outfile.write('last-updated-datetime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.last_updated_datetime, input_name='last-updated-datetime'))
        if self.linked_data_uri is not None and 'linked_data_uri' not in already_processed:
            already_processed.add('linked_data_uri')
            showIndent(outfile, level)
            outfile.write('linked_data_uri="%s",\n' % (self.linked_data_uri,))
        if self.hierarchy is not None and 'hierarchy' not in already_processed:
            already_processed.add('hierarchy')
            showIndent(outfile, level)
            outfile.write('hierarchy=%d,\n' % (self.hierarchy,))
        if self.default_currency is not None and 'default_currency' not in already_processed:
            already_processed.add('default_currency')
            showIndent(outfile, level)
            outfile.write('default_currency="%s",\n' % (self.default_currency,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.iati_identifier is not None:
            showIndent(outfile, level)
            outfile.write('iati_identifier=model_.iati_identifier(\n')
            self.iati_identifier.exportLiteral(outfile, level, name_='iati_identifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.reporting_org is not None:
            showIndent(outfile, level)
            outfile.write('reporting_org=model_.reporting_org(\n')
            self.reporting_org.exportLiteral(outfile, level, name_='reporting_org')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('title=model_.textRequiredType(\n')
            self.title.exportLiteral(outfile, level, name_='title')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('description=[\n')
        level += 1
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('model_.descriptionType(\n')
            description_.exportLiteral(outfile, level, name_='descriptionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('participating_org=[\n')
        level += 1
        for participating_org_ in self.participating_org:
            showIndent(outfile, level)
            outfile.write('model_.participating_org(\n')
            participating_org_.exportLiteral(outfile, level, name_='participating-org')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('other_identifier=[\n')
        level += 1
        for other_identifier_ in self.other_identifier:
            showIndent(outfile, level)
            outfile.write('model_.other_identifier(\n')
            other_identifier_.exportLiteral(outfile, level, name_='other-identifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.activity_status is not None:
            showIndent(outfile, level)
            outfile.write('activity_status=model_.activity_status(\n')
            self.activity_status.exportLiteral(outfile, level, name_='activity_status')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('activity_date=[\n')
        level += 1
        for activity_date_ in self.activity_date:
            showIndent(outfile, level)
            outfile.write('model_.activity_date(\n')
            activity_date_.exportLiteral(outfile, level, name_='activity-date')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('contact_info=[\n')
        level += 1
        for contact_info_ in self.contact_info:
            showIndent(outfile, level)
            outfile.write('model_.contact_info(\n')
            contact_info_.exportLiteral(outfile, level, name_='contact-info')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.activity_scope is not None:
            showIndent(outfile, level)
            outfile.write('activity_scope=model_.activity_scope(\n')
            self.activity_scope.exportLiteral(outfile, level, name_='activity_scope')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('recipient_country=[\n')
        level += 1
        for recipient_country_ in self.recipient_country:
            showIndent(outfile, level)
            outfile.write('model_.recipient_country(\n')
            recipient_country_.exportLiteral(outfile, level, name_='recipient-country')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('recipient_region=[\n')
        level += 1
        for recipient_region_ in self.recipient_region:
            showIndent(outfile, level)
            outfile.write('model_.recipient_region(\n')
            recipient_region_.exportLiteral(outfile, level, name_='recipient-region')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('location=[\n')
        level += 1
        for location_ in self.location:
            showIndent(outfile, level)
            outfile.write('model_.location(\n')
            location_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('sector=[\n')
        level += 1
        for sector_ in self.sector:
            showIndent(outfile, level)
            outfile.write('model_.sector(\n')
            sector_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.country_budget_items is not None:
            showIndent(outfile, level)
            outfile.write('country_budget_items=model_.country_budget_items(\n')
            self.country_budget_items.exportLiteral(outfile, level, name_='country_budget_items')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('policy_marker=[\n')
        level += 1
        for policy_marker_ in self.policy_marker:
            showIndent(outfile, level)
            outfile.write('model_.policy_marker(\n')
            policy_marker_.exportLiteral(outfile, level, name_='policy-marker')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.collaboration_type is not None:
            showIndent(outfile, level)
            outfile.write('collaboration_type=model_.collaboration_type(\n')
            self.collaboration_type.exportLiteral(outfile, level, name_='collaboration_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.default_flow_type is not None:
            showIndent(outfile, level)
            outfile.write('default_flow_type=model_.default_flow_type(\n')
            self.default_flow_type.exportLiteral(outfile, level, name_='default_flow_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.default_finance_type is not None:
            showIndent(outfile, level)
            outfile.write('default_finance_type=model_.default_finance_type(\n')
            self.default_finance_type.exportLiteral(outfile, level, name_='default_finance_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.default_aid_type is not None:
            showIndent(outfile, level)
            outfile.write('default_aid_type=model_.default_aid_type(\n')
            self.default_aid_type.exportLiteral(outfile, level, name_='default_aid_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.default_tied_status is not None:
            showIndent(outfile, level)
            outfile.write('default_tied_status=model_.default_tied_status(\n')
            self.default_tied_status.exportLiteral(outfile, level, name_='default_tied_status')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('budget=[\n')
        level += 1
        for budget_ in self.budget:
            showIndent(outfile, level)
            outfile.write('model_.budget(\n')
            budget_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('planned_disbursement=[\n')
        level += 1
        for planned_disbursement_ in self.planned_disbursement:
            showIndent(outfile, level)
            outfile.write('model_.planned_disbursement(\n')
            planned_disbursement_.exportLiteral(outfile, level, name_='planned-disbursement')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.capital_spend is not None:
            showIndent(outfile, level)
            outfile.write('capital_spend=model_.capital_spend(\n')
            self.capital_spend.exportLiteral(outfile, level, name_='capital_spend')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('transaction=[\n')
        level += 1
        for transaction_ in self.transaction:
            showIndent(outfile, level)
            outfile.write('model_.transaction(\n')
            transaction_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('document_link=[\n')
        level += 1
        for document_link_ in self.document_link:
            showIndent(outfile, level)
            outfile.write('model_.document_link(\n')
            document_link_.exportLiteral(outfile, level, name_='document-link')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('related_activity=[\n')
        level += 1
        for related_activity_ in self.related_activity:
            showIndent(outfile, level)
            outfile.write('model_.related_activity(\n')
            related_activity_.exportLiteral(outfile, level, name_='related-activity')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('legacy_data=[\n')
        level += 1
        for legacy_data_ in self.legacy_data:
            showIndent(outfile, level)
            outfile.write('model_.legacy_data(\n')
            legacy_data_.exportLiteral(outfile, level, name_='legacy-data')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.conditions is not None:
            showIndent(outfile, level)
            outfile.write('conditions=model_.conditions(\n')
            self.conditions.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('result=[\n')
        level += 1
        for result_ in self.result:
            showIndent(outfile, level)
            outfile.write('model_.result(\n')
            result_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.crs_add is not None:
            showIndent(outfile, level)
            outfile.write('crs_add=model_.crs_add(\n')
            self.crs_add.exportLiteral(outfile, level, name_='crs_add')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fss is not None:
            showIndent(outfile, level)
            outfile.write('fss=model_.fss(\n')
            self.fss.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('last-updated-datetime', node)
        if value is not None and 'last-updated-datetime' not in already_processed:
            already_processed.add('last-updated-datetime')
            try:
                self.last_updated_datetime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (last-updated-datetime): %s' % exp)
        value = find_attr_value_('linked-data-uri', node)
        if value is not None and 'linked-data-uri' not in already_processed:
            already_processed.add('linked-data-uri')
            self.linked_data_uri = value
        value = find_attr_value_('hierarchy', node)
        if value is not None and 'hierarchy' not in already_processed:
            already_processed.add('hierarchy')
            try:
                self.hierarchy = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('default-currency', node)
        if value is not None and 'default-currency' not in already_processed:
            already_processed.add('default-currency')
            self.default_currency = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'iati-identifier':
            obj_ = iati_identifier.factory()
            obj_.build(child_)
            self.iati_identifier = obj_
            obj_.original_tagname_ = 'iati-identifier'
        elif nodeName_ == 'reporting-org':
            obj_ = reporting_org.factory()
            obj_.build(child_)
            self.reporting_org = obj_
            obj_.original_tagname_ = 'reporting-org'
        elif nodeName_ == 'title':
            obj_ = textRequiredType.factory()
            obj_.build(child_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'description':
            obj_ = descriptionType.factory()
            obj_.build(child_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'participating-org':
            obj_ = participating_org.factory()
            obj_.build(child_)
            self.participating_org.append(obj_)
            obj_.original_tagname_ = 'participating-org'
        elif nodeName_ == 'other-identifier':
            obj_ = other_identifier.factory()
            obj_.build(child_)
            self.other_identifier.append(obj_)
            obj_.original_tagname_ = 'other-identifier'
        elif nodeName_ == 'activity-status':
            obj_ = activity_status.factory()
            obj_.build(child_)
            self.activity_status = obj_
            obj_.original_tagname_ = 'activity-status'
        elif nodeName_ == 'activity-date':
            obj_ = activity_date.factory()
            obj_.build(child_)
            self.activity_date.append(obj_)
            obj_.original_tagname_ = 'activity-date'
        elif nodeName_ == 'contact-info':
            obj_ = contact_info.factory()
            obj_.build(child_)
            self.contact_info.append(obj_)
            obj_.original_tagname_ = 'contact-info'
        elif nodeName_ == 'activity-scope':
            obj_ = activity_scope.factory()
            obj_.build(child_)
            self.activity_scope = obj_
            obj_.original_tagname_ = 'activity-scope'
        elif nodeName_ == 'recipient-country':
            obj_ = recipient_country.factory()
            obj_.build(child_)
            self.recipient_country.append(obj_)
            obj_.original_tagname_ = 'recipient-country'
        elif nodeName_ == 'recipient-region':
            obj_ = recipient_region.factory()
            obj_.build(child_)
            self.recipient_region.append(obj_)
            obj_.original_tagname_ = 'recipient-region'
        elif nodeName_ == 'location':
            obj_ = location.factory()
            obj_.build(child_)
            self.location.append(obj_)
            obj_.original_tagname_ = 'location'
        elif nodeName_ == 'sector':
            obj_ = sector.factory()
            obj_.build(child_)
            self.sector.append(obj_)
            obj_.original_tagname_ = 'sector'
        elif nodeName_ == 'country-budget-items':
            obj_ = country_budget_items.factory()
            obj_.build(child_)
            self.country_budget_items = obj_
            obj_.original_tagname_ = 'country-budget-items'
        elif nodeName_ == 'policy-marker':
            obj_ = policy_marker.factory()
            obj_.build(child_)
            self.policy_marker.append(obj_)
            obj_.original_tagname_ = 'policy-marker'
        elif nodeName_ == 'collaboration-type':
            obj_ = collaboration_type.factory()
            obj_.build(child_)
            self.collaboration_type = obj_
            obj_.original_tagname_ = 'collaboration-type'
        elif nodeName_ == 'default-flow-type':
            obj_ = default_flow_type.factory()
            obj_.build(child_)
            self.default_flow_type = obj_
            obj_.original_tagname_ = 'default-flow-type'
        elif nodeName_ == 'default-finance-type':
            obj_ = default_finance_type.factory()
            obj_.build(child_)
            self.default_finance_type = obj_
            obj_.original_tagname_ = 'default-finance-type'
        elif nodeName_ == 'default-aid-type':
            obj_ = default_aid_type.factory()
            obj_.build(child_)
            self.default_aid_type = obj_
            obj_.original_tagname_ = 'default-aid-type'
        elif nodeName_ == 'default-tied-status':
            obj_ = default_tied_status.factory()
            obj_.build(child_)
            self.default_tied_status = obj_
            obj_.original_tagname_ = 'default-tied-status'
        elif nodeName_ == 'budget':
            obj_ = budget.factory()
            obj_.build(child_)
            self.budget.append(obj_)
            obj_.original_tagname_ = 'budget'
        elif nodeName_ == 'planned-disbursement':
            obj_ = planned_disbursement.factory()
            obj_.build(child_)
            self.planned_disbursement.append(obj_)
            obj_.original_tagname_ = 'planned-disbursement'
        elif nodeName_ == 'capital-spend':
            obj_ = capital_spend.factory()
            obj_.build(child_)
            self.capital_spend = obj_
            obj_.original_tagname_ = 'capital-spend'
        elif nodeName_ == 'transaction':
            obj_ = transaction.factory()
            obj_.build(child_)
            self.transaction.append(obj_)
            obj_.original_tagname_ = 'transaction'
        elif nodeName_ == 'document-link':
            obj_ = document_link.factory()
            obj_.build(child_)
            self.document_link.append(obj_)
            obj_.original_tagname_ = 'document-link'
        elif nodeName_ == 'related-activity':
            obj_ = related_activity.factory()
            obj_.build(child_)
            self.related_activity.append(obj_)
            obj_.original_tagname_ = 'related-activity'
        elif nodeName_ == 'legacy-data':
            obj_ = legacy_data.factory()
            obj_.build(child_)
            self.legacy_data.append(obj_)
            obj_.original_tagname_ = 'legacy-data'
        elif nodeName_ == 'conditions':
            obj_ = conditions.factory()
            obj_.build(child_)
            self.conditions = obj_
            obj_.original_tagname_ = 'conditions'
        elif nodeName_ == 'result':
            obj_ = result.factory()
            obj_.build(child_)
            self.result.append(obj_)
            obj_.original_tagname_ = 'result'
        elif nodeName_ == 'crs-add':
            obj_ = crs_add.factory()
            obj_.build(child_)
            self.crs_add = obj_
            obj_.original_tagname_ = 'crs-add'
        elif nodeName_ == 'fss':
            obj_ = fss.factory()
            obj_.build(child_)
            self.fss = obj_
            obj_.original_tagname_ = 'fss'
        else:
            obj_ = self.gds_build_any(child_, 'iati-activity')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class iati_activity


class iati_identifier(GeneratedsSuper):
    """A globally unique identifier for the activity. This MUST be prefixed
    with EITHER the current IATI organisation identifier for the
    reporting organisation (reporting-org/@ref) OR a previous
    identifier reported in other-identifier, and suffixed with the
    organisation’s own activity identifier. The prefix and the
    suffix should be separated by a hyphen "-". Once an activity has
    been reported to IATI its identifier MUST NOT be changed in
    subsequent updates."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if iati_identifier.subclass:
            return iati_identifier.subclass(*args_, **kwargs_)
        else:
            return iati_identifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='iati-identifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='iati-identifier')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='iati-identifier', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='iati-identifier'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='iati-identifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='iati-identifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class iati_identifier


class participating_org(GeneratedsSuper):
    """An organisation involved with the activity. May be a donor, fund,
    agency, etc. Specifying the @ref identifier is strongly
    recommended. May contain the organisation name as narrative. If
    the reporting organisation plays a role in the activity it
    should be repeated here. One organisation may play more than one
    role (eg, funding and implementing): in such a case each role
    should be reported and the name of the organisation repeated.
    Machine-readable identification string for the organisation.
    Must be in the format {Registration Agency} - (Registration
    Number} where {Registration Agency} is a valid code in the
    Registration Agency code list and {Registration Number } is a
    valid identifier issued by the {Registration Agency}. If this is
    not present then the narrative MUST contain the name of the
    organisation. The type of organisation issuing the report. See
    IATI codelist for values. An IATI code describing the
    organisation's role in the activity (donor, agency, etc.)."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, role=None, ref=None, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.role = _cast(None, role)
        self.ref = _cast(None, ref)
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if participating_org.subclass:
            return participating_org.subclass(*args_, **kwargs_)
        else:
            return participating_org(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='participating-org', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='participating-org')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='participating-org', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='participating-org'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='participating-org', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='participating-org'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            showIndent(outfile, level)
            outfile.write('role="%s",\n' % (self.role,))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'participating-org')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class participating_org


class activity_scope(GeneratedsSuper):
    """The geographical scope of the activity: regional, national, sub-
    national, etc. The geographical scope. See IATI codelist for
    values."""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if activity_scope.subclass:
            return activity_scope.subclass(*args_, **kwargs_)
        else:
            return activity_scope(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='activity-scope', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='activity-scope')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='activity-scope', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='activity-scope'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='activity-scope', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='activity-scope'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'activity-scope')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class activity_scope


class recipient_country(GeneratedsSuper):
    """A country that will benefit from this activity. If a specific
    country is not known the recipient-region element should be used
    instead. For geographical location, use the location element.
    Multiple countries and regions can be reported, in which case
    the percentage attribute MUST be used to specify the share of
    total commitments across all reported countries and regions. The
    country can also be specified at transaction rather than
    activity level. If recipient-country OR recipient-region are
    reported at the transaction level, ALL transactions MUST contain
    a recipient-country or recipient-region element and iati-
    activity/recipient-country and iati-activity/recipient-region
    MUST NOT be used. ISO 3166-1 alpha-2 code for the country. The
    percentage of total commitments or total activity budget
    allocated to this country. Content must be a positive decimal
    number between 0 and 100, with no percentage sign. Percentages
    for all reported countries and regions MUST add up to 100%"""
    subclass = None
    superclass = None
    def __init__(self, percentage=None, code=None, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.percentage = _cast(float, percentage)
        self.code = _cast(None, code)
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if recipient_country.subclass:
            return recipient_country.subclass(*args_, **kwargs_)
        else:
            return recipient_country(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_percentage(self): return self.percentage
    def set_percentage(self, percentage): self.percentage = percentage
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='recipient-country', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='recipient-country')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='recipient-country', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='recipient-country'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            outfile.write(' percentage="%s"' % self.gds_format_float(self.percentage, input_name='percentage'))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='recipient-country', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='recipient-country'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            showIndent(outfile, level)
            outfile.write('percentage=%f,\n' % (self.percentage,))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('percentage', node)
        if value is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            try:
                self.percentage = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (percentage): %s' % exp)
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'recipient-country')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class recipient_country


class recipient_region(GeneratedsSuper):
    """A supranational geopolitical region that will benefit from this
    activity. For sub-national geographical location, use the
    location element. Multiple countries and regions can be
    reported, in which case the percentage attribute MUST be used to
    specifiy the share of total commitments across all reported
    countries and regions. Recipient-region must not be used merely
    to describe the region of a country reported in recipient-
    region, but ONLY if the region is a recipient IN ADDITION to the
    country. Region can also be reported at transaction rather than
    activity level. If transaction/recipient-country AND/OR
    transaction/recipient-region are used THEN ALL transaction
    elements MUST contain a recipient-country and/or recipient-
    region element AND iati-activity/recipient-region and iati-
    activity/recipient-region MUST NOT be used AND each transaction
    MUST only contain one recipient-country or recipient-region.
    Either an OECD DAC or UN region code. Codelist is determined by
    vocabulary attribute. An IATI code for the vocabulary from which
    the region code is drawn. If it is not present 1 - 'OECD DAC' is
    assumed. The percentage of total commitments or total activity
    budget allocated to this region. Content must be a positive
    decimal number between 0 and 100, with no percentage sign.
    Percentages for all reported countries and regions MUST add up
    to 100%"""
    subclass = None
    superclass = None
    def __init__(self, percentage=None, code=None, vocabulary=None, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.percentage = _cast(float, percentage)
        self.code = _cast(None, code)
        self.vocabulary = _cast(None, vocabulary)
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if recipient_region.subclass:
            return recipient_region.subclass(*args_, **kwargs_)
        else:
            return recipient_region(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_percentage(self): return self.percentage
    def set_percentage(self, percentage): self.percentage = percentage
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='recipient-region', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='recipient-region')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='recipient-region', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='recipient-region'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            outfile.write(' percentage="%s"' % self.gds_format_float(self.percentage, input_name='percentage'))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            outfile.write(' vocabulary=%s' % (self.gds_format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='recipient-region', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='recipient-region'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            showIndent(outfile, level)
            outfile.write('percentage=%f,\n' % (self.percentage,))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            showIndent(outfile, level)
            outfile.write('vocabulary="%s",\n' % (self.vocabulary,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('percentage', node)
        if value is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            try:
                self.percentage = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (percentage): %s' % exp)
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('vocabulary', node)
        if value is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            self.vocabulary = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'recipient-region')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class recipient_region


class collaboration_type(GeneratedsSuper):
    """The type of collaboration involved in the activity's disbursements,
    e.g. "bilateral" or "multilateral". A code from the OECD DAC CRS
    "Bi_Multi" codelist."""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if collaboration_type.subclass:
            return collaboration_type.subclass(*args_, **kwargs_)
        else:
            return collaboration_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='collaboration-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='collaboration-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='collaboration-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='collaboration-type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='collaboration-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='collaboration-type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'collaboration-type')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class collaboration_type


class default_flow_type(GeneratedsSuper):
    """Whether the activity is funded by Official Development Assistance
    (ODA), Other Official Flows (OOF), etc A code from the OECD DAC
    CRS "Type of flow" codelist"""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if default_flow_type.subclass:
            return default_flow_type.subclass(*args_, **kwargs_)
        else:
            return default_flow_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='default-flow-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='default-flow-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='default-flow-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='default-flow-type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='default-flow-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='default-flow-type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'default-flow-type')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class default_flow_type


class default_aid_type(GeneratedsSuper):
    """The type of aid being supplied (project-type intervention, budget
    support, debt relief, etc.). This element specifies a default
    for all the activity's financial transactions; it can be
    overridden at the individual transaction level. A code from the
    OECD DAC CRS "Type of aid" codelist"""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if default_aid_type.subclass:
            return default_aid_type.subclass(*args_, **kwargs_)
        else:
            return default_aid_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='default-aid-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='default-aid-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='default-aid-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='default-aid-type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='default-aid-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='default-aid-type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'default-aid-type')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class default_aid_type


class default_finance_type(GeneratedsSuper):
    """The type of finance (e.g. grant, loan, debt relief, etc). This the
    default value for all transactions in the activity report; it
    can be overridden by individual transactions. A code from the
    OECD DAC CRS "Type of finance" codelist"""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if default_finance_type.subclass:
            return default_finance_type.subclass(*args_, **kwargs_)
        else:
            return default_finance_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='default-finance-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='default-finance-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='default-finance-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='default-finance-type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='default-finance-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='default-finance-type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'default-finance-type')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class default_finance_type


class other_identifier(GeneratedsSuper):
    """An other identifier for the activity. This may be a publishers own
    identifier that it wishes to record with the activity. This
    element is also used to trace changes to activity identifiers,
    for example when and organisation has changed it's organisation
    identifier. The identifier you wish to report. This can be used
    to report a number of different types of identifiers. See the
    OtherIdentifierType codelist for details and options. The type
    of identifier being reported, taken from the OtherIdentifierType
    codelist."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, ref=None, owner_org=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.ref = _cast(None, ref)
        self.owner_org = owner_org
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if other_identifier.subclass:
            return other_identifier.subclass(*args_, **kwargs_)
        else:
            return other_identifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_owner_org(self): return self.owner_org
    def set_owner_org(self, owner_org): self.owner_org = owner_org
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.owner_org is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='other-identifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='other-identifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='other-identifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='other-identifier'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='other-identifier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.owner_org is not None:
            self.owner_org.export(outfile, level, namespace_, name_='owner-org', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='other-identifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.owner_org is not None:
            showIndent(outfile, level)
            outfile.write('owner_org=model_.owner_orgType(\n')
            self.owner_org.exportLiteral(outfile, level, name_='owner_org')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'owner-org':
            obj_ = owner_orgType.factory()
            obj_.build(child_)
            self.owner_org = obj_
            obj_.original_tagname_ = 'owner-org'
        else:
            obj_ = self.gds_build_any(child_, 'other-identifier')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class other_identifier


class sector(GeneratedsSuper):
    """A recognised code, from a recognised vocabulary, classifying the
    purpose of the activity. Sector MUST EITHER be reported here OR
    at transaction level for ALL transactions An IATI code for the
    vocabulary (see codelist) used for sector classifications. If
    omitted, OECD DAC 5-digit Purpose Codes are assumed. It is
    recommended that OECD DAC 5-digit Purpose Codes are used
    wherever possible. It is also recommended that if a publisher
    has its own classification system or systems then the
    vocabularies 99 or 98 (Reporting Organisation's own
    vocabularies) should be used in addition to DAC codes.
    Publishers using 98 or 99 must also include a narrative in the
    narrative element. Note that if multiple sector codes are used
    in multiple vocabularies, then each vocabulary's percentages
    should add up to 100%. Sector can also be reported at the
    transaction level rather than the activity level. Sector must
    only be reported at EITHER transaction level OR activity level.
    The code for the sector. The percentage of total commitments or
    total activity budget to this item. Content must be a positive
    decimal number between 0 and 100, with no percentage sign. All
    reported sectors from the same vocabulary MUST add up to 100%"""
    subclass = None
    superclass = None
    def __init__(self, percentage=None, code=None, vocabulary=None, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.percentage = _cast(float, percentage)
        self.code = _cast(None, code)
        self.vocabulary = _cast(None, vocabulary)
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if sector.subclass:
            return sector.subclass(*args_, **kwargs_)
        else:
            return sector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_percentage(self): return self.percentage
    def set_percentage(self, percentage): self.percentage = percentage
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='sector', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sector')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='sector', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sector'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            outfile.write(' percentage="%s"' % self.gds_format_float(self.percentage, input_name='percentage'))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            outfile.write(' vocabulary=%s' % (self.gds_format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='sector', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='sector'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            showIndent(outfile, level)
            outfile.write('percentage=%f,\n' % (self.percentage,))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            showIndent(outfile, level)
            outfile.write('vocabulary="%s",\n' % (self.vocabulary,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('percentage', node)
        if value is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            try:
                self.percentage = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (percentage): %s' % exp)
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('vocabulary', node)
        if value is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            self.vocabulary = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'sector')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class sector


class activity_date(GeneratedsSuper):
    """The planned and actual start and completion dates of the activity.
    Start dates may reflect either the commencement of funding,
    planning or physical activity. End dates should, wherever
    possible, reflect the ending of physical activity. The narrative
    content may contain text (e.g. 2011Q1) for accurately recording
    less specific dates such as month, quarter, or year. An IATI
    code defining the type of activity date being reported."""
    subclass = None
    superclass = None
    def __init__(self, iso_date=None, type_=None, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if isinstance(iso_date, basestring):
            initvalue_ = datetime_.datetime.strptime(iso_date, '%Y-%m-%d').date()
        else:
            initvalue_ = iso_date
        self.iso_date = initvalue_
        self.type_ = _cast(None, type_)
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if activity_date.subclass:
            return activity_date.subclass(*args_, **kwargs_)
        else:
            return activity_date(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_iso_date(self): return self.iso_date
    def set_iso_date(self, iso_date): self.iso_date = iso_date
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='activity-date', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='activity-date')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='activity-date', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='activity-date'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            outfile.write(' iso-date="%s"' % self.gds_format_date(self.iso_date, input_name='iso-date'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='activity-date', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='activity-date'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            showIndent(outfile, level)
            outfile.write('iso-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.iso_date, input_name='iso-date'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iso-date', node)
        if value is not None and 'iso-date' not in already_processed:
            already_processed.add('iso-date')
            try:
                self.iso_date = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (iso-date): %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'activity-date')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class activity_date


class activity_status(GeneratedsSuper):
    """The current status of the activity. See codelist for values. An IATI
    code defining the current status of the activity."""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if activity_status.subclass:
            return activity_status.subclass(*args_, **kwargs_)
        else:
            return activity_status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='activity-status', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='activity-status')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='activity-status', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='activity-status'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='activity-status', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='activity-status'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'activity-status')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class activity_status


class contact_info(GeneratedsSuper):
    """Contact information for the activity. Specify whatever is available.
    You may repeat this element for each contact person. The type of
    contact. See IATI codelist for values."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, organisation=None, department=None, person_name=None, job_title=None, telephone=None, email=None, website=None, mailing_address=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.organisation = organisation
        self.department = department
        self.person_name = person_name
        self.job_title = job_title
        if telephone is None:
            self.telephone = []
        else:
            self.telephone = telephone
        if email is None:
            self.email = []
        else:
            self.email = email
        if website is None:
            self.website = []
        else:
            self.website = website
        if mailing_address is None:
            self.mailing_address = []
        else:
            self.mailing_address = mailing_address
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if contact_info.subclass:
            return contact_info.subclass(*args_, **kwargs_)
        else:
            return contact_info(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_organisation(self): return self.organisation
    def set_organisation(self, organisation): self.organisation = organisation
    def get_department(self): return self.department
    def set_department(self, department): self.department = department
    def get_person_name(self): return self.person_name
    def set_person_name(self, person_name): self.person_name = person_name
    def get_job_title(self): return self.job_title
    def set_job_title(self, job_title): self.job_title = job_title
    def get_telephone(self): return self.telephone
    def set_telephone(self, telephone): self.telephone = telephone
    def add_telephone(self, value): self.telephone.append(value)
    def insert_telephone_at(self, index, value): self.telephone.insert(index, value)
    def replace_telephone_at(self, index, value): self.telephone[index] = value
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def add_email(self, value): self.email.append(value)
    def insert_email_at(self, index, value): self.email.insert(index, value)
    def replace_email_at(self, index, value): self.email[index] = value
    def get_website(self): return self.website
    def set_website(self, website): self.website = website
    def add_website(self, value): self.website.append(value)
    def insert_website_at(self, index, value): self.website.insert(index, value)
    def replace_website_at(self, index, value): self.website[index] = value
    def get_mailing_address(self): return self.mailing_address
    def set_mailing_address(self, mailing_address): self.mailing_address = mailing_address
    def add_mailing_address(self, value): self.mailing_address.append(value)
    def insert_mailing_address_at(self, index, value): self.mailing_address.insert(index, value)
    def replace_mailing_address_at(self, index, value): self.mailing_address[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.organisation is not None or
            self.department is not None or
            self.person_name is not None or
            self.job_title is not None or
            self.telephone or
            self.email or
            self.website or
            self.mailing_address or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='contact-info', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contact-info')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='contact-info', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='contact-info'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='contact-info', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.organisation is not None:
            self.organisation.export(outfile, level, namespace_, name_='organisation', pretty_print=pretty_print)
        if self.department is not None:
            self.department.export(outfile, level, namespace_, name_='department', pretty_print=pretty_print)
        if self.person_name is not None:
            self.person_name.export(outfile, level, namespace_, name_='person-name', pretty_print=pretty_print)
        if self.job_title is not None:
            self.job_title.export(outfile, level, namespace_, name_='job-title', pretty_print=pretty_print)
        for telephone_ in self.telephone:
            telephone_.export(outfile, level, namespace_, name_='telephone', pretty_print=pretty_print)
        for email_ in self.email:
            email_.export(outfile, level, namespace_, name_='email', pretty_print=pretty_print)
        for website_ in self.website:
            website_.export(outfile, level, namespace_, name_='website', pretty_print=pretty_print)
        for mailing_address_ in self.mailing_address:
            mailing_address_.export(outfile, level, namespace_, name_='mailing-address', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='contact-info'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.organisation is not None:
            showIndent(outfile, level)
            outfile.write('organisation=model_.textRequiredType(\n')
            self.organisation.exportLiteral(outfile, level, name_='organisation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.department is not None:
            showIndent(outfile, level)
            outfile.write('department=model_.textRequiredType(\n')
            self.department.exportLiteral(outfile, level, name_='department')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.person_name is not None:
            showIndent(outfile, level)
            outfile.write('person_name=model_.textRequiredType(\n')
            self.person_name.exportLiteral(outfile, level, name_='person_name')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.job_title is not None:
            showIndent(outfile, level)
            outfile.write('job_title=model_.textRequiredType(\n')
            self.job_title.exportLiteral(outfile, level, name_='job_title')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('telephone=[\n')
        level += 1
        for telephone_ in self.telephone:
            showIndent(outfile, level)
            outfile.write('model_.telephoneType(\n')
            telephone_.exportLiteral(outfile, level, name_='telephoneType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('email=[\n')
        level += 1
        for email_ in self.email:
            showIndent(outfile, level)
            outfile.write('model_.emailType(\n')
            email_.exportLiteral(outfile, level, name_='emailType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('website=[\n')
        level += 1
        for website_ in self.website:
            showIndent(outfile, level)
            outfile.write('model_.websiteType(\n')
            website_.exportLiteral(outfile, level, name_='websiteType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('mailing_address=[\n')
        level += 1
        for mailing_address_ in self.mailing_address:
            showIndent(outfile, level)
            outfile.write('model_.textRequiredType(\n')
            mailing_address_.exportLiteral(outfile, level, name_='textRequiredType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'organisation':
            obj_ = textRequiredType.factory()
            obj_.build(child_)
            self.organisation = obj_
            obj_.original_tagname_ = 'organisation'
        elif nodeName_ == 'department':
            obj_ = textRequiredType.factory()
            obj_.build(child_)
            self.department = obj_
            obj_.original_tagname_ = 'department'
        elif nodeName_ == 'person-name':
            obj_ = textRequiredType.factory()
            obj_.build(child_)
            self.person_name = obj_
            obj_.original_tagname_ = 'person-name'
        elif nodeName_ == 'job-title':
            obj_ = textRequiredType.factory()
            obj_.build(child_)
            self.job_title = obj_
            obj_.original_tagname_ = 'job-title'
        elif nodeName_ == 'telephone':
            obj_ = telephoneType.factory()
            obj_.build(child_)
            self.telephone.append(obj_)
            obj_.original_tagname_ = 'telephone'
        elif nodeName_ == 'email':
            obj_ = emailType.factory()
            obj_.build(child_)
            self.email.append(obj_)
            obj_.original_tagname_ = 'email'
        elif nodeName_ == 'website':
            obj_ = websiteType.factory()
            obj_.build(child_)
            self.website.append(obj_)
            obj_.original_tagname_ = 'website'
        elif nodeName_ == 'mailing-address':
            obj_ = textRequiredType.factory()
            obj_.build(child_)
            self.mailing_address.append(obj_)
            obj_.original_tagname_ = 'mailing-address'
        else:
            obj_ = self.gds_build_any(child_, 'contact-info')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class contact_info


class default_tied_status(GeneratedsSuper):
    """Whether the aid is untied, tied, or partially tied. This element
    specifies a default for all the activity's financial
    transactions; it can be overridden at the individual transaction
    level. If an activity is partially tied it is recommended that
    tied and untied commitments are reported as separate
    transactions and that transaction/tied-status is used to
    classify them. An IATI code interpreting the usage of Columns
    36-38 of the CRS++ reporting format. (Amount tied, Amount
    partially untied, Amount tied)"""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if default_tied_status.subclass:
            return default_tied_status.subclass(*args_, **kwargs_)
        else:
            return default_tied_status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='default-tied-status', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='default-tied-status')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='default-tied-status', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='default-tied-status'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='default-tied-status', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='default-tied-status'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'default-tied-status')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class default_tied_status


class policy_marker(GeneratedsSuper):
    """A policy or theme addressed by the activity. This element was
    designed for the reporting of OECD DAC CRS policy markers
    (columns 20-23 and 28-31 of the CRS++ reporting format) but the
    vocabulary attribute allows it use by other (including local)
    systems. This element can be repeated for each policy marker. An
    IATI code for the vocabulary to be used to define policy
    markers. If omitted then the OECD DAC vocabulary is assumed. A
    policy marker code from the codelist specified in the
    vocabulary. An OECD DAC CRS code indicating the significance of
    the policy marker for this activity. This codelist should be
    used for all vocabularies. Markers MUST NOT be reported unless a
    value for significance is present."""
    subclass = None
    superclass = None
    def __init__(self, code=None, vocabulary=None, significance=None, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        self.vocabulary = _cast(None, vocabulary)
        self.significance = _cast(None, significance)
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if policy_marker.subclass:
            return policy_marker.subclass(*args_, **kwargs_)
        else:
            return policy_marker(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def get_significance(self): return self.significance
    def set_significance(self, significance): self.significance = significance
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='policy-marker', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='policy-marker')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='policy-marker', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='policy-marker'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            outfile.write(' vocabulary=%s' % (self.gds_format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
        if self.significance is not None and 'significance' not in already_processed:
            already_processed.add('significance')
            outfile.write(' significance=%s' % (self.gds_format_string(quote_attrib(self.significance).encode(ExternalEncoding), input_name='significance'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='policy-marker', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='policy-marker'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            showIndent(outfile, level)
            outfile.write('vocabulary="%s",\n' % (self.vocabulary,))
        if self.significance is not None and 'significance' not in already_processed:
            already_processed.add('significance')
            showIndent(outfile, level)
            outfile.write('significance="%s",\n' % (self.significance,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('vocabulary', node)
        if value is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            self.vocabulary = value
        value = find_attr_value_('significance', node)
        if value is not None and 'significance' not in already_processed:
            already_processed.add('significance')
            self.significance = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'policy-marker')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class policy_marker


class capital_spend(GeneratedsSuper):
    """The percentage of the total commitment that is for capital spending
    The percentage of the total commitment allocated to or planned
    for capital expenditure. Content must be a positive decimal
    number between 0 and 100, with no percentage sign."""
    subclass = None
    superclass = None
    def __init__(self, percentage=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.percentage = _cast(float, percentage)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if capital_spend.subclass:
            return capital_spend.subclass(*args_, **kwargs_)
        else:
            return capital_spend(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_percentage(self): return self.percentage
    def set_percentage(self, percentage): self.percentage = percentage
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='capital-spend', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='capital-spend')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='capital-spend', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='capital-spend'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            outfile.write(' percentage="%s"' % self.gds_format_float(self.percentage, input_name='percentage'))
    def exportChildren(self, outfile, level, namespace_='', name_='capital-spend', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='capital-spend'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            showIndent(outfile, level)
            outfile.write('percentage=%f,\n' % (self.percentage,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('percentage', node)
        if value is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            try:
                self.percentage = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (percentage): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'capital-spend')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class capital_spend


class transaction(GeneratedsSuper):
    """Transactions recording committed or actual funds flowing in or out
    of an aid activity. An internal reference linking this
    transaction back to the publisher's financial management system."""
    subclass = None
    superclass = None
    def __init__(self, ref=None, transaction_type=None, transaction_date=None, value=None, description=None, provider_org=None, receiver_org=None, disbursement_channel=None, sector=None, recipient_country=None, recipient_region=None, flow_type=None, finance_type=None, aid_type=None, tied_status=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.ref = _cast(None, ref)
        self.transaction_type = transaction_type
        self.transaction_date = transaction_date
        self.value = value
        self.description = description
        self.provider_org = provider_org
        self.receiver_org = receiver_org
        self.disbursement_channel = disbursement_channel
        if sector is None:
            self.sector = []
        else:
            self.sector = sector
        self.recipient_country = recipient_country
        self.recipient_region = recipient_region
        self.flow_type = flow_type
        self.finance_type = finance_type
        self.aid_type = aid_type
        self.tied_status = tied_status
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if transaction.subclass:
            return transaction.subclass(*args_, **kwargs_)
        else:
            return transaction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transaction_type(self): return self.transaction_type
    def set_transaction_type(self, transaction_type): self.transaction_type = transaction_type
    def get_transaction_date(self): return self.transaction_date
    def set_transaction_date(self, transaction_date): self.transaction_date = transaction_date
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_provider_org(self): return self.provider_org
    def set_provider_org(self, provider_org): self.provider_org = provider_org
    def get_receiver_org(self): return self.receiver_org
    def set_receiver_org(self, receiver_org): self.receiver_org = receiver_org
    def get_disbursement_channel(self): return self.disbursement_channel
    def set_disbursement_channel(self, disbursement_channel): self.disbursement_channel = disbursement_channel
    def get_sector(self): return self.sector
    def set_sector(self, sector): self.sector = sector
    def add_sector(self, value): self.sector.append(value)
    def insert_sector_at(self, index, value): self.sector.insert(index, value)
    def replace_sector_at(self, index, value): self.sector[index] = value
    def get_recipient_country(self): return self.recipient_country
    def set_recipient_country(self, recipient_country): self.recipient_country = recipient_country
    def get_recipient_region(self): return self.recipient_region
    def set_recipient_region(self, recipient_region): self.recipient_region = recipient_region
    def get_flow_type(self): return self.flow_type
    def set_flow_type(self, flow_type): self.flow_type = flow_type
    def get_finance_type(self): return self.finance_type
    def set_finance_type(self, finance_type): self.finance_type = finance_type
    def get_aid_type(self): return self.aid_type
    def set_aid_type(self, aid_type): self.aid_type = aid_type
    def get_tied_status(self): return self.tied_status
    def set_tied_status(self, tied_status): self.tied_status = tied_status
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.transaction_type is not None or
            self.transaction_date is not None or
            self.value is not None or
            self.description is not None or
            self.provider_org is not None or
            self.receiver_org is not None or
            self.disbursement_channel is not None or
            self.sector or
            self.recipient_country is not None or
            self.recipient_region is not None or
            self.flow_type is not None or
            self.finance_type is not None or
            self.aid_type is not None or
            self.tied_status is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='transaction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transaction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='transaction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='transaction'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='transaction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.transaction_type is not None:
            self.transaction_type.export(outfile, level, namespace_, name_='transaction-type', pretty_print=pretty_print)
        if self.transaction_date is not None:
            self.transaction_date.export(outfile, level, namespace_, name_='transaction-date', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
        if self.provider_org is not None:
            self.provider_org.export(outfile, level, namespace_, name_='provider-org', pretty_print=pretty_print)
        if self.receiver_org is not None:
            self.receiver_org.export(outfile, level, namespace_, name_='receiver-org', pretty_print=pretty_print)
        if self.disbursement_channel is not None:
            self.disbursement_channel.export(outfile, level, namespace_, name_='disbursement-channel', pretty_print=pretty_print)
        for sector_ in self.sector:
            sector_.export(outfile, level, namespace_, name_='sector', pretty_print=pretty_print)
        if self.recipient_country is not None:
            self.recipient_country.export(outfile, level, namespace_, name_='recipient-country', pretty_print=pretty_print)
        if self.recipient_region is not None:
            self.recipient_region.export(outfile, level, namespace_, name_='recipient-region', pretty_print=pretty_print)
        if self.flow_type is not None:
            self.flow_type.export(outfile, level, namespace_, name_='flow-type', pretty_print=pretty_print)
        if self.finance_type is not None:
            self.finance_type.export(outfile, level, namespace_, name_='finance-type', pretty_print=pretty_print)
        if self.aid_type is not None:
            self.aid_type.export(outfile, level, namespace_, name_='aid-type', pretty_print=pretty_print)
        if self.tied_status is not None:
            self.tied_status.export(outfile, level, namespace_, name_='tied-status', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='transaction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.transaction_type is not None:
            showIndent(outfile, level)
            outfile.write('transaction_type=model_.transaction_typeType(\n')
            self.transaction_type.exportLiteral(outfile, level, name_='transaction_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.transaction_date is not None:
            showIndent(outfile, level)
            outfile.write('transaction_date=model_.transaction_dateType(\n')
            self.transaction_date.exportLiteral(outfile, level, name_='transaction_date')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.currencyType(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.textRequiredType(\n')
            self.description.exportLiteral(outfile, level, name_='description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.provider_org is not None:
            showIndent(outfile, level)
            outfile.write('provider_org=model_.provider_orgType(\n')
            self.provider_org.exportLiteral(outfile, level, name_='provider_org')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.receiver_org is not None:
            showIndent(outfile, level)
            outfile.write('receiver_org=model_.receiver_orgType(\n')
            self.receiver_org.exportLiteral(outfile, level, name_='receiver_org')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.disbursement_channel is not None:
            showIndent(outfile, level)
            outfile.write('disbursement_channel=model_.disbursement_channelType(\n')
            self.disbursement_channel.exportLiteral(outfile, level, name_='disbursement_channel')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('sector=[\n')
        level += 1
        for sector_ in self.sector:
            showIndent(outfile, level)
            outfile.write('model_.sectorType(\n')
            sector_.exportLiteral(outfile, level, name_='sectorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.recipient_country is not None:
            showIndent(outfile, level)
            outfile.write('recipient_country=model_.recipient_countryType(\n')
            self.recipient_country.exportLiteral(outfile, level, name_='recipient_country')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.recipient_region is not None:
            showIndent(outfile, level)
            outfile.write('recipient_region=model_.recipient_regionType(\n')
            self.recipient_region.exportLiteral(outfile, level, name_='recipient_region')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.flow_type is not None:
            showIndent(outfile, level)
            outfile.write('flow_type=model_.flow_typeType(\n')
            self.flow_type.exportLiteral(outfile, level, name_='flow_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.finance_type is not None:
            showIndent(outfile, level)
            outfile.write('finance_type=model_.finance_typeType(\n')
            self.finance_type.exportLiteral(outfile, level, name_='finance_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.aid_type is not None:
            showIndent(outfile, level)
            outfile.write('aid_type=model_.aid_typeType(\n')
            self.aid_type.exportLiteral(outfile, level, name_='aid_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.tied_status is not None:
            showIndent(outfile, level)
            outfile.write('tied_status=model_.tied_statusType(\n')
            self.tied_status.exportLiteral(outfile, level, name_='tied_status')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'transaction-type':
            obj_ = transaction_typeType.factory()
            obj_.build(child_)
            self.transaction_type = obj_
            obj_.original_tagname_ = 'transaction-type'
        elif nodeName_ == 'transaction-date':
            obj_ = transaction_dateType.factory()
            obj_.build(child_)
            self.transaction_date = obj_
            obj_.original_tagname_ = 'transaction-date'
        elif nodeName_ == 'value':
            obj_ = currencyType.factory()
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'description':
            obj_ = textRequiredType.factory()
            obj_.build(child_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'provider-org':
            obj_ = provider_orgType.factory()
            obj_.build(child_)
            self.provider_org = obj_
            obj_.original_tagname_ = 'provider-org'
        elif nodeName_ == 'receiver-org':
            obj_ = receiver_orgType.factory()
            obj_.build(child_)
            self.receiver_org = obj_
            obj_.original_tagname_ = 'receiver-org'
        elif nodeName_ == 'disbursement-channel':
            obj_ = disbursement_channelType.factory()
            obj_.build(child_)
            self.disbursement_channel = obj_
            obj_.original_tagname_ = 'disbursement-channel'
        elif nodeName_ == 'sector':
            obj_ = sectorType.factory()
            obj_.build(child_)
            self.sector.append(obj_)
            obj_.original_tagname_ = 'sector'
        elif nodeName_ == 'recipient-country':
            obj_ = recipient_countryType.factory()
            obj_.build(child_)
            self.recipient_country = obj_
            obj_.original_tagname_ = 'recipient-country'
        elif nodeName_ == 'recipient-region':
            obj_ = recipient_regionType.factory()
            obj_.build(child_)
            self.recipient_region = obj_
            obj_.original_tagname_ = 'recipient-region'
        elif nodeName_ == 'flow-type':
            obj_ = flow_typeType.factory()
            obj_.build(child_)
            self.flow_type = obj_
            obj_.original_tagname_ = 'flow-type'
        elif nodeName_ == 'finance-type':
            obj_ = finance_typeType.factory()
            obj_.build(child_)
            self.finance_type = obj_
            obj_.original_tagname_ = 'finance-type'
        elif nodeName_ == 'aid-type':
            obj_ = aid_typeType.factory()
            obj_.build(child_)
            self.aid_type = obj_
            obj_.original_tagname_ = 'aid-type'
        elif nodeName_ == 'tied-status':
            obj_ = tied_statusType.factory()
            obj_.build(child_)
            self.tied_status = obj_
            obj_.original_tagname_ = 'tied-status'
        else:
            obj_ = self.gds_build_any(child_, 'transaction')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class transaction


class location(GeneratedsSuper):
    """The sub-national geographical identification of the target locations
    of an activity. These can be described by gazetteer reference,
    coordinates, administrative areas or a textual description. Any
    number of locations may be reported. An internal reference that
    describes the location in the reporting organisation's own
    system."""
    subclass = None
    superclass = None
    def __init__(self, ref=None, location_reach=None, location_id=None, name=None, description=None, activity_description=None, administrative=None, point=None, exactness=None, location_class=None, feature_designation=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.ref = _cast(None, ref)
        self.location_reach = location_reach
        if location_id is None:
            self.location_id = []
        else:
            self.location_id = location_id
        self.name = name
        self.description = description
        self.activity_description = activity_description
        if administrative is None:
            self.administrative = []
        else:
            self.administrative = administrative
        self.point = point
        self.exactness = exactness
        self.location_class = location_class
        self.feature_designation = feature_designation
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if location.subclass:
            return location.subclass(*args_, **kwargs_)
        else:
            return location(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_location_reach(self): return self.location_reach
    def set_location_reach(self, location_reach): self.location_reach = location_reach
    def get_location_id(self): return self.location_id
    def set_location_id(self, location_id): self.location_id = location_id
    def add_location_id(self, value): self.location_id.append(value)
    def insert_location_id_at(self, index, value): self.location_id.insert(index, value)
    def replace_location_id_at(self, index, value): self.location_id[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_activity_description(self): return self.activity_description
    def set_activity_description(self, activity_description): self.activity_description = activity_description
    def get_administrative(self): return self.administrative
    def set_administrative(self, administrative): self.administrative = administrative
    def add_administrative(self, value): self.administrative.append(value)
    def insert_administrative_at(self, index, value): self.administrative.insert(index, value)
    def replace_administrative_at(self, index, value): self.administrative[index] = value
    def get_point(self): return self.point
    def set_point(self, point): self.point = point
    def get_exactness(self): return self.exactness
    def set_exactness(self, exactness): self.exactness = exactness
    def get_location_class(self): return self.location_class
    def set_location_class(self, location_class): self.location_class = location_class
    def get_feature_designation(self): return self.feature_designation
    def set_feature_designation(self, feature_designation): self.feature_designation = feature_designation
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.location_reach is not None or
            self.location_id or
            self.name is not None or
            self.description is not None or
            self.activity_description is not None or
            self.administrative or
            self.point is not None or
            self.exactness is not None or
            self.location_class is not None or
            self.feature_designation is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='location', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='location')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='location', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='location'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='location', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.location_reach is not None:
            self.location_reach.export(outfile, level, namespace_, name_='location-reach', pretty_print=pretty_print)
        for location_id_ in self.location_id:
            location_id_.export(outfile, level, namespace_, name_='location-id', pretty_print=pretty_print)
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
        if self.activity_description is not None:
            self.activity_description.export(outfile, level, namespace_, name_='activity-description', pretty_print=pretty_print)
        for administrative_ in self.administrative:
            administrative_.export(outfile, level, namespace_, name_='administrative', pretty_print=pretty_print)
        if self.point is not None:
            self.point.export(outfile, level, namespace_, name_='point', pretty_print=pretty_print)
        if self.exactness is not None:
            self.exactness.export(outfile, level, namespace_, name_='exactness', pretty_print=pretty_print)
        if self.location_class is not None:
            self.location_class.export(outfile, level, namespace_, name_='location-class', pretty_print=pretty_print)
        if self.feature_designation is not None:
            self.feature_designation.export(outfile, level, namespace_, name_='feature-designation', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='location'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.location_reach is not None:
            showIndent(outfile, level)
            outfile.write('location_reach=model_.location_reachType(\n')
            self.location_reach.exportLiteral(outfile, level, name_='location_reach')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('location_id=[\n')
        level += 1
        for location_id_ in self.location_id:
            showIndent(outfile, level)
            outfile.write('model_.location_idType(\n')
            location_id_.exportLiteral(outfile, level, name_='location-idType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=model_.textRequiredType(\n')
            self.name.exportLiteral(outfile, level, name_='name')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.textRequiredType(\n')
            self.description.exportLiteral(outfile, level, name_='description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.activity_description is not None:
            showIndent(outfile, level)
            outfile.write('activity_description=model_.textRequiredType(\n')
            self.activity_description.exportLiteral(outfile, level, name_='activity_description')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('administrative=[\n')
        level += 1
        for administrative_ in self.administrative:
            showIndent(outfile, level)
            outfile.write('model_.administrativeType(\n')
            administrative_.exportLiteral(outfile, level, name_='administrativeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.point is not None:
            showIndent(outfile, level)
            outfile.write('point=model_.pointType(\n')
            self.point.exportLiteral(outfile, level, name_='point')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.exactness is not None:
            showIndent(outfile, level)
            outfile.write('exactness=model_.exactnessType(\n')
            self.exactness.exportLiteral(outfile, level, name_='exactness')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.location_class is not None:
            showIndent(outfile, level)
            outfile.write('location_class=model_.location_classType(\n')
            self.location_class.exportLiteral(outfile, level, name_='location_class')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.feature_designation is not None:
            showIndent(outfile, level)
            outfile.write('feature_designation=model_.feature_designationType(\n')
            self.feature_designation.exportLiteral(outfile, level, name_='feature_designation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'location-reach':
            obj_ = location_reachType.factory()
            obj_.build(child_)
            self.location_reach = obj_
            obj_.original_tagname_ = 'location-reach'
        elif nodeName_ == 'location-id':
            obj_ = location_idType.factory()
            obj_.build(child_)
            self.location_id.append(obj_)
            obj_.original_tagname_ = 'location-id'
        elif nodeName_ == 'name':
            obj_ = textRequiredType.factory()
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'description':
            obj_ = textRequiredType.factory()
            obj_.build(child_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'activity-description':
            obj_ = textRequiredType.factory()
            obj_.build(child_)
            self.activity_description = obj_
            obj_.original_tagname_ = 'activity-description'
        elif nodeName_ == 'administrative':
            obj_ = administrativeType.factory()
            obj_.build(child_)
            self.administrative.append(obj_)
            obj_.original_tagname_ = 'administrative'
        elif nodeName_ == 'point':
            obj_ = pointType.factory()
            obj_.build(child_)
            self.point = obj_
            obj_.original_tagname_ = 'point'
        elif nodeName_ == 'exactness':
            obj_ = exactnessType.factory()
            obj_.build(child_)
            self.exactness = obj_
            obj_.original_tagname_ = 'exactness'
        elif nodeName_ == 'location-class':
            obj_ = location_classType.factory()
            obj_.build(child_)
            self.location_class = obj_
            obj_.original_tagname_ = 'location-class'
        elif nodeName_ == 'feature-designation':
            obj_ = feature_designationType.factory()
            obj_.build(child_)
            self.feature_designation = obj_
            obj_.original_tagname_ = 'feature-designation'
        else:
            obj_ = self.gds_build_any(child_, 'location')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class location


class country_budget_items(GeneratedsSuper):
    """This item encodes the alignment of activities with both the
    functional and administrative classifications used in the
    recipient country's Chart of Accounts. This applies to both on-
    and off-budget activities. An IATI code for the common
    functional classification or country system (This allows for
    common codes, country-specific, or any other classification
    agreed between countries and donors)."""
    subclass = None
    superclass = None
    def __init__(self, vocabulary=None, budget_item=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.vocabulary = _cast(None, vocabulary)
        if budget_item is None:
            self.budget_item = []
        else:
            self.budget_item = budget_item
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if country_budget_items.subclass:
            return country_budget_items.subclass(*args_, **kwargs_)
        else:
            return country_budget_items(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_budget_item(self): return self.budget_item
    def set_budget_item(self, budget_item): self.budget_item = budget_item
    def add_budget_item(self, value): self.budget_item.append(value)
    def insert_budget_item_at(self, index, value): self.budget_item.insert(index, value)
    def replace_budget_item_at(self, index, value): self.budget_item[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.budget_item or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='country-budget-items', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='country-budget-items')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='country-budget-items', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='country-budget-items'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            outfile.write(' vocabulary=%s' % (self.gds_format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='country-budget-items', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for budget_item_ in self.budget_item:
            budget_item_.export(outfile, level, namespace_, name_='budget-item', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='country-budget-items'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            showIndent(outfile, level)
            outfile.write('vocabulary="%s",\n' % (self.vocabulary,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('budget_item=[\n')
        level += 1
        for budget_item_ in self.budget_item:
            showIndent(outfile, level)
            outfile.write('model_.budget_itemType(\n')
            budget_item_.exportLiteral(outfile, level, name_='budget-itemType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vocabulary', node)
        if value is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            self.vocabulary = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'budget-item':
            obj_ = budget_itemType.factory()
            obj_.build(child_)
            self.budget_item.append(obj_)
            obj_.original_tagname_ = 'budget-item'
        else:
            obj_ = self.gds_build_any(child_, 'country-budget-items')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class country_budget_items


class related_activity(GeneratedsSuper):
    """Another separately reported IATI activity that is related to this
    one. The 'type' attribute describes the type of relationship:
    eg. parent, child, multifunded ... A valid activity identifier
    (as defined in iati-activity/iati-identifier). An IATI code for
    the type of relationship"""
    subclass = None
    superclass = None
    def __init__(self, type_=None, ref=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.ref = _cast(None, ref)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if related_activity.subclass:
            return related_activity.subclass(*args_, **kwargs_)
        else:
            return related_activity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='related-activity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='related-activity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='related-activity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='related-activity'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='related-activity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='related-activity'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'related-activity')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class related_activity


class legacy_data(GeneratedsSuper):
    """The legacy data element allows for the reporting of values held in a
    field in the reporting organisation's system which is similar,
    but not identical to an IATI element. The original field name in
    the reporting organisation's system The original field value in
    the reporting organisation's system The name of the equivalent
    IATI element."""
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, iati_equivalent=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        self.iati_equivalent = _cast(None, iati_equivalent)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if legacy_data.subclass:
            return legacy_data.subclass(*args_, **kwargs_)
        else:
            return legacy_data(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_iati_equivalent(self): return self.iati_equivalent
    def set_iati_equivalent(self, iati_equivalent): self.iati_equivalent = iati_equivalent
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='legacy-data', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='legacy-data')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='legacy-data', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='legacy-data'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.iati_equivalent is not None and 'iati_equivalent' not in already_processed:
            already_processed.add('iati_equivalent')
            outfile.write(' iati-equivalent=%s' % (self.gds_format_string(quote_attrib(self.iati_equivalent).encode(ExternalEncoding), input_name='iati-equivalent'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='legacy-data', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='legacy-data'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.iati_equivalent is not None and 'iati_equivalent' not in already_processed:
            already_processed.add('iati_equivalent')
            showIndent(outfile, level)
            outfile.write('iati_equivalent="%s",\n' % (self.iati_equivalent,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('iati-equivalent', node)
        if value is not None and 'iati-equivalent' not in already_processed:
            already_processed.add('iati-equivalent')
            self.iati_equivalent = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'legacy-data')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class legacy_data


class result(GeneratedsSuper):
    """A container for reporting outputs, outcomes, impacts and other
    results that stem directly from the activity. This may be
    repeated for each type of result reported. An IATI code for the
    type of result being reported. Boolean flag indicating whether
    the data in the result set are suitable for aggregation."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, aggregation_status=None, title=None, description=None, indicator=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.aggregation_status = _cast(bool, aggregation_status)
        self.title = title
        self.description = description
        if indicator is None:
            self.indicator = []
        else:
            self.indicator = indicator
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if result.subclass:
            return result.subclass(*args_, **kwargs_)
        else:
            return result(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_indicator(self): return self.indicator
    def set_indicator(self, indicator): self.indicator = indicator
    def add_indicator(self, value): self.indicator.append(value)
    def insert_indicator_at(self, index, value): self.indicator.insert(index, value)
    def replace_indicator_at(self, index, value): self.indicator[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_aggregation_status(self): return self.aggregation_status
    def set_aggregation_status(self, aggregation_status): self.aggregation_status = aggregation_status
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.title is not None or
            self.description is not None or
            self.indicator or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='result', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='result')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='result', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='result'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.aggregation_status is not None and 'aggregation_status' not in already_processed:
            already_processed.add('aggregation_status')
            outfile.write(' aggregation-status="%s"' % self.gds_format_boolean(self.aggregation_status, input_name='aggregation-status'))
    def exportChildren(self, outfile, level, namespace_='', name_='result', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            self.title.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
        for indicator_ in self.indicator:
            indicator_.export(outfile, level, namespace_, name_='indicator', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='result'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.aggregation_status is not None and 'aggregation_status' not in already_processed:
            already_processed.add('aggregation_status')
            showIndent(outfile, level)
            outfile.write('aggregation_status=%s,\n' % (self.aggregation_status,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('title=model_.title(\n')
            self.title.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('indicator=[\n')
        level += 1
        for indicator_ in self.indicator:
            showIndent(outfile, level)
            outfile.write('model_.indicatorType(\n')
            indicator_.exportLiteral(outfile, level, name_='indicatorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('aggregation-status', node)
        if value is not None and 'aggregation-status' not in already_processed:
            already_processed.add('aggregation-status')
            if value in ('true', '1'):
                self.aggregation_status = True
            elif value in ('false', '0'):
                self.aggregation_status = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            obj_ = textRequiredType.factory()
            obj_.build(child_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'indicator':
            obj_ = indicatorType.factory()
            obj_.build(child_)
            self.indicator.append(obj_)
            obj_.original_tagname_ = 'indicator'
        else:
            obj_ = self.gds_build_any(child_, 'result')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class result


class conditions(GeneratedsSuper):
    """Specific terms and conditions attached to the activity that, if not
    met, may influence the delivery of commitments made by
    participating organisations. A yes/no (1/0) value stating
    whether there are conditions attached to the activity. It is
    strongly recommended that this attribute is reported, even if
    there are no condtions attached (i.e. attached="0")"""
    subclass = None
    superclass = None
    def __init__(self, attached=None, condition=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.attached = _cast(bool, attached)
        if condition is None:
            self.condition = []
        else:
            self.condition = condition
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if conditions.subclass:
            return conditions.subclass(*args_, **kwargs_)
        else:
            return conditions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def add_condition(self, value): self.condition.append(value)
    def insert_condition_at(self, index, value): self.condition.insert(index, value)
    def replace_condition_at(self, index, value): self.condition[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_attached(self): return self.attached
    def set_attached(self, attached): self.attached = attached
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.condition or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='conditions', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='conditions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='conditions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='conditions'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.attached is not None and 'attached' not in already_processed:
            already_processed.add('attached')
            outfile.write(' attached="%s"' % self.gds_format_boolean(self.attached, input_name='attached'))
    def exportChildren(self, outfile, level, namespace_='', name_='conditions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for condition_ in self.condition:
            condition_.export(outfile, level, namespace_, name_='condition', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='conditions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.attached is not None and 'attached' not in already_processed:
            already_processed.add('attached')
            showIndent(outfile, level)
            outfile.write('attached=%s,\n' % (self.attached,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('condition=[\n')
        level += 1
        for condition_ in self.condition:
            showIndent(outfile, level)
            outfile.write('model_.conditionType(\n')
            condition_.exportLiteral(outfile, level, name_='conditionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attached', node)
        if value is not None and 'attached' not in already_processed:
            already_processed.add('attached')
            if value in ('true', '1'):
                self.attached = True
            elif value in ('false', '0'):
                self.attached = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'condition':
            obj_ = conditionType.factory()
            obj_.build(child_)
            self.condition.append(obj_)
            obj_.original_tagname_ = 'condition'
        else:
            obj_ = self.gds_build_any(child_, 'conditions')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class conditions


class budget(GeneratedsSuper):
    """The value of the aid activity's budget for each financial quarter or
    year over the lifetime of the activity. The total budget for an
    activity should be reported as a commitment in the transaction
    element. The purpose of this element is to provide
    predictability for recipient planning on an annual basis.
    Whether this is the original budget (prepared when the original
    commitment was made) or has subsequently been revised"""
    subclass = None
    superclass = None
    def __init__(self, type_=None, period_start=None, period_end=None, value=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.period_start = period_start
        self.period_end = period_end
        self.value = value
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if budget.subclass:
            return budget.subclass(*args_, **kwargs_)
        else:
            return budget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_period_start(self): return self.period_start
    def set_period_start(self, period_start): self.period_start = period_start
    def get_period_end(self): return self.period_end
    def set_period_end(self, period_end): self.period_end = period_end
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.period_start is not None or
            self.period_end is not None or
            self.value is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='budget', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='budget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='budget', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='budget'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='budget', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.period_start is not None:
            self.period_start.export(outfile, level, namespace_, name_='period-start', pretty_print=pretty_print)
        if self.period_end is not None:
            self.period_end.export(outfile, level, namespace_, name_='period-end', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='budget'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.period_start is not None:
            showIndent(outfile, level)
            outfile.write('period_start=model_.period_startType1(\n')
            self.period_start.exportLiteral(outfile, level, name_='period_start')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.period_end is not None:
            showIndent(outfile, level)
            outfile.write('period_end=model_.period_endType2(\n')
            self.period_end.exportLiteral(outfile, level, name_='period_end')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.currencyType(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'period-start':
            obj_ = period_startType1.factory()
            obj_.build(child_)
            self.period_start = obj_
            obj_.original_tagname_ = 'period-start'
        elif nodeName_ == 'period-end':
            obj_ = period_endType2.factory()
            obj_.build(child_)
            self.period_end = obj_
            obj_.original_tagname_ = 'period-end'
        elif nodeName_ == 'value':
            obj_ = currencyType.factory()
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        else:
            obj_ = self.gds_build_any(child_, 'budget')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class budget


class planned_disbursement(GeneratedsSuper):
    """The planned disbursement element should only be used to report
    specific planned cash transfers. These should be reported for a
    specific date or a meaningfully predictable period. These
    transactions should be reported in addition to budgets - which
    are typically annual breakdowns of the total activity
    commitment. Whether this is an original plan (prepared when the
    original commitment was made) or has subsequently been revised."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, period_start=None, period_end=None, value=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.period_start = period_start
        self.period_end = period_end
        self.value = value
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if planned_disbursement.subclass:
            return planned_disbursement.subclass(*args_, **kwargs_)
        else:
            return planned_disbursement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_period_start(self): return self.period_start
    def set_period_start(self, period_start): self.period_start = period_start
    def get_period_end(self): return self.period_end
    def set_period_end(self, period_end): self.period_end = period_end
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.period_start is not None or
            self.period_end is not None or
            self.value is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='planned-disbursement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='planned-disbursement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='planned-disbursement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='planned-disbursement'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='planned-disbursement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.period_start is not None:
            self.period_start.export(outfile, level, namespace_, name_='period-start', pretty_print=pretty_print)
        if self.period_end is not None:
            self.period_end.export(outfile, level, namespace_, name_='period-end', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='planned-disbursement'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.period_start is not None:
            showIndent(outfile, level)
            outfile.write('period_start=model_.period_startType3(\n')
            self.period_start.exportLiteral(outfile, level, name_='period_start')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.period_end is not None:
            showIndent(outfile, level)
            outfile.write('period_end=model_.period_endType4(\n')
            self.period_end.exportLiteral(outfile, level, name_='period_end')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.currencyType(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'period-start':
            obj_ = period_startType3.factory()
            obj_.build(child_)
            self.period_start = obj_
            obj_.original_tagname_ = 'period-start'
        elif nodeName_ == 'period-end':
            obj_ = period_endType4.factory()
            obj_.build(child_)
            self.period_end = obj_
            obj_.original_tagname_ = 'period-end'
        elif nodeName_ == 'value':
            obj_ = currencyType.factory()
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        else:
            obj_ = self.gds_build_any(child_, 'planned-disbursement')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class planned_disbursement


class crs_add(GeneratedsSuper):
    """Additional items specific to CRS++ reporting."""
    subclass = None
    superclass = None
    def __init__(self, other_flags=None, loan_terms=None, loan_status=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if other_flags is None:
            self.other_flags = []
        else:
            self.other_flags = other_flags
        self.loan_terms = loan_terms
        self.loan_status = loan_status
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if crs_add.subclass:
            return crs_add.subclass(*args_, **kwargs_)
        else:
            return crs_add(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_other_flags(self): return self.other_flags
    def set_other_flags(self, other_flags): self.other_flags = other_flags
    def add_other_flags(self, value): self.other_flags.append(value)
    def insert_other_flags_at(self, index, value): self.other_flags.insert(index, value)
    def replace_other_flags_at(self, index, value): self.other_flags[index] = value
    def get_loan_terms(self): return self.loan_terms
    def set_loan_terms(self, loan_terms): self.loan_terms = loan_terms
    def get_loan_status(self): return self.loan_status
    def set_loan_status(self, loan_status): self.loan_status = loan_status
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.other_flags or
            self.loan_terms is not None or
            self.loan_status is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='crs-add', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='crs-add')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='crs-add', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='crs-add'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='crs-add', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for other_flags_ in self.other_flags:
            other_flags_.export(outfile, level, namespace_, name_='other-flags', pretty_print=pretty_print)
        if self.loan_terms is not None:
            self.loan_terms.export(outfile, level, namespace_, name_='loan-terms', pretty_print=pretty_print)
        if self.loan_status is not None:
            self.loan_status.export(outfile, level, namespace_, name_='loan-status', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='crs-add'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('other_flags=[\n')
        level += 1
        for other_flags_ in self.other_flags:
            showIndent(outfile, level)
            outfile.write('model_.other_flagsType(\n')
            other_flags_.exportLiteral(outfile, level, name_='other-flagsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.loan_terms is not None:
            showIndent(outfile, level)
            outfile.write('loan_terms=model_.loan_termsType(\n')
            self.loan_terms.exportLiteral(outfile, level, name_='loan_terms')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.loan_status is not None:
            showIndent(outfile, level)
            outfile.write('loan_status=model_.loan_statusType(\n')
            self.loan_status.exportLiteral(outfile, level, name_='loan_status')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'other-flags':
            obj_ = other_flagsType.factory()
            obj_.build(child_)
            self.other_flags.append(obj_)
            obj_.original_tagname_ = 'other-flags'
        elif nodeName_ == 'loan-terms':
            obj_ = loan_termsType.factory()
            obj_.build(child_)
            self.loan_terms = obj_
            obj_.original_tagname_ = 'loan-terms'
        elif nodeName_ == 'loan-status':
            obj_ = loan_statusType.factory()
            obj_.build(child_)
            self.loan_status = obj_
            obj_.original_tagname_ = 'loan-status'
        else:
            obj_ = self.gds_build_any(child_, 'crs-add')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class crs_add


class fss(GeneratedsSuper):
    """This section allows entry of data required for the OECD DAC Forward
    Spending Survey at an activity level. The exact date when the
    information was collected or extracted from donors' aid
    management systems. True if the partner country is a priority
    partner country. If there are plans to phase out operations from
    the partner country, this column shows the projected year of
    last disbursements."""
    subclass = None
    superclass = None
    def __init__(self, priority=None, phaseout_year=None, extraction_date=None, forecast=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.priority = _cast(bool, priority)
        self.phaseout_year = _cast(float, phaseout_year)
        if isinstance(extraction_date, basestring):
            initvalue_ = datetime_.datetime.strptime(extraction_date, '%Y-%m-%d').date()
        else:
            initvalue_ = extraction_date
        self.extraction_date = initvalue_
        if forecast is None:
            self.forecast = []
        else:
            self.forecast = forecast
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if fss.subclass:
            return fss.subclass(*args_, **kwargs_)
        else:
            return fss(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_forecast(self): return self.forecast
    def set_forecast(self, forecast): self.forecast = forecast
    def add_forecast(self, value): self.forecast.append(value)
    def insert_forecast_at(self, index, value): self.forecast.insert(index, value)
    def replace_forecast_at(self, index, value): self.forecast[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_priority(self): return self.priority
    def set_priority(self, priority): self.priority = priority
    def get_phaseout_year(self): return self.phaseout_year
    def set_phaseout_year(self, phaseout_year): self.phaseout_year = phaseout_year
    def get_extraction_date(self): return self.extraction_date
    def set_extraction_date(self, extraction_date): self.extraction_date = extraction_date
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.forecast or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='fss', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fss')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='fss', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fss'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            outfile.write(' priority="%s"' % self.gds_format_boolean(self.priority, input_name='priority'))
        if self.phaseout_year is not None and 'phaseout_year' not in already_processed:
            already_processed.add('phaseout_year')
            outfile.write(' phaseout-year="%s"' % self.gds_format_float(self.phaseout_year, input_name='phaseout-year'))
        if self.extraction_date is not None and 'extraction_date' not in already_processed:
            already_processed.add('extraction_date')
            outfile.write(' extraction-date="%s"' % self.gds_format_date(self.extraction_date, input_name='extraction-date'))
    def exportChildren(self, outfile, level, namespace_='', name_='fss', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for forecast_ in self.forecast:
            forecast_.export(outfile, level, namespace_, name_='forecast', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='fss'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            showIndent(outfile, level)
            outfile.write('priority=%s,\n' % (self.priority,))
        if self.phaseout_year is not None and 'phaseout_year' not in already_processed:
            already_processed.add('phaseout_year')
            showIndent(outfile, level)
            outfile.write('phaseout_year=%f,\n' % (self.phaseout_year,))
        if self.extraction_date is not None and 'extraction_date' not in already_processed:
            already_processed.add('extraction_date')
            showIndent(outfile, level)
            outfile.write('extraction-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.extraction_date, input_name='extraction-date'))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('forecast=[\n')
        level += 1
        for forecast_ in self.forecast:
            showIndent(outfile, level)
            outfile.write('model_.forecastType(\n')
            forecast_.exportLiteral(outfile, level, name_='forecastType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('priority', node)
        if value is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            if value in ('true', '1'):
                self.priority = True
            elif value in ('false', '0'):
                self.priority = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('phaseout-year', node)
        if value is not None and 'phaseout-year' not in already_processed:
            already_processed.add('phaseout-year')
            try:
                self.phaseout_year = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (phaseout-year): %s' % exp)
        value = find_attr_value_('extraction-date', node)
        if value is not None and 'extraction-date' not in already_processed:
            already_processed.add('extraction-date')
            try:
                self.extraction_date = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (extraction-date): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'forecast':
            obj_ = forecastType.factory()
            obj_.build(child_)
            self.forecast.append(obj_)
            obj_.original_tagname_ = 'forecast'
        else:
            obj_ = self.gds_build_any(child_, 'fss')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class fss


class document_link(GeneratedsSuper):
    """A link to an online, publicly accessible web page or document. The
    target URL of the external document, e.g.
    "http://www.example.org/doc.odt". An IANA code for the MIME type
    of the document being referenced, e.g. "application/pdf"."""
    subclass = None
    superclass = None
    def __init__(self, url=None, format=None, title=None, category=None, language=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.url = _cast(None, url)
        self.format = _cast(None, format)
        self.title = title
        if category is None:
            self.category = []
        else:
            self.category = category
        if language is None:
            self.language = []
        else:
            self.language = language
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if document_link.subclass:
            return document_link.subclass(*args_, **kwargs_)
        else:
            return document_link(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def add_category(self, value): self.category.append(value)
    def insert_category_at(self, index, value): self.category.insert(index, value)
    def replace_category_at(self, index, value): self.category[index] = value
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def add_language(self, value): self.language.append(value)
    def insert_language_at(self, index, value): self.language.insert(index, value)
    def replace_language_at(self, index, value): self.language[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.title is not None or
            self.category or
            self.language or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='document-link', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='document-link')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='document-link', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='document-link'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            outfile.write(' url=%s' % (self.gds_format_string(quote_attrib(self.url).encode(ExternalEncoding), input_name='url'), ))
        if self.format is not None and 'format' not in already_processed:
            already_processed.add('format')
            outfile.write(' format=%s' % (self.gds_format_string(quote_attrib(self.format).encode(ExternalEncoding), input_name='format'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='document-link', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            self.title.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        for category_ in self.category:
            category_.export(outfile, level, namespace_, name_='category', pretty_print=pretty_print)
        for language_ in self.language:
            language_.export(outfile, level, namespace_, name_='language', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='document-link'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            showIndent(outfile, level)
            outfile.write('url="%s",\n' % (self.url,))
        if self.format is not None and 'format' not in already_processed:
            already_processed.add('format')
            showIndent(outfile, level)
            outfile.write('format="%s",\n' % (self.format,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('title=model_.title(\n')
            self.title.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('category=[\n')
        level += 1
        for category_ in self.category:
            showIndent(outfile, level)
            outfile.write('model_.categoryType(\n')
            category_.exportLiteral(outfile, level, name_='categoryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('language=[\n')
        level += 1
        for language_ in self.language:
            showIndent(outfile, level)
            outfile.write('model_.languageType(\n')
            language_.exportLiteral(outfile, level, name_='languageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('url', node)
        if value is not None and 'url' not in already_processed:
            already_processed.add('url')
            self.url = value
        value = find_attr_value_('format', node)
        if value is not None and 'format' not in already_processed:
            already_processed.add('format')
            self.format = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            obj_ = textRequiredType.factory()
            obj_.build(child_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'category':
            obj_ = categoryType.factory()
            obj_.build(child_)
            self.category.append(obj_)
            obj_.original_tagname_ = 'category'
        elif nodeName_ == 'language':
            obj_ = languageType.factory()
            obj_.build(child_)
            self.language.append(obj_)
            obj_.original_tagname_ = 'language'
        else:
            obj_ = self.gds_build_any(child_, 'document-link')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class document_link


class currencyType(GeneratedsSuper):
    """Data type for an element containing a currency value."""
    subclass = None
    superclass = None
    def __init__(self, currency=None, value_date=None, valueOf_=None):
        self.original_tagname_ = None
        self.currency = _cast(None, currency)
        if isinstance(value_date, basestring):
            initvalue_ = datetime_.datetime.strptime(value_date, '%Y-%m-%d').date()
        else:
            initvalue_ = value_date
        self.value_date = initvalue_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if currencyType.subclass:
            return currencyType.subclass(*args_, **kwargs_)
        else:
            return currencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_value_date(self): return self.value_date
    def set_value_date(self, value_date): self.value_date = value_date
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='currencyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='currencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='currencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='currencyType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            outfile.write(' currency=%s' % (self.gds_format_string(quote_attrib(self.currency).encode(ExternalEncoding), input_name='currency'), ))
        if self.value_date is not None and 'value_date' not in already_processed:
            already_processed.add('value_date')
            outfile.write(' value-date="%s"' % self.gds_format_date(self.value_date, input_name='value-date'))
    def exportChildren(self, outfile, level, namespace_='', name_='currencyType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='currencyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            showIndent(outfile, level)
            outfile.write('currency="%s",\n' % (self.currency,))
        if self.value_date is not None and 'value_date' not in already_processed:
            already_processed.add('value_date')
            showIndent(outfile, level)
            outfile.write('value-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.value_date, input_name='value-date'))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            self.currency = value
        value = find_attr_value_('value-date', node)
        if value is not None and 'value-date' not in already_processed:
            already_processed.add('value-date')
            try:
                self.value_date = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (value-date): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class currencyType


class narrative(GeneratedsSuper):
    """The free text name or description of the item being described. This
    can be repeated in multiple languages. ISO 639-1 code specifying
    the language of text in this element. If a default language is
    specified in the iati-activity element it does not have to be
    repeated here."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, valueOf_=None):
        self.original_tagname_ = None
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if narrative.subclass:
            return narrative.subclass(*args_, **kwargs_)
        else:
            return narrative(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='narrative', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='narrative')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='narrative', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='narrative'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (quote_attrib(self.lang), ))
    def exportChildren(self, outfile, level, namespace_='', name_='narrative', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='narrative'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang=%s,\n' % (self.lang,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class narrative


class description(GeneratedsSuper):
    """A longer, human-readable description."""
    subclass = None
    superclass = None
    def __init__(self, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if description.subclass:
            return description.subclass(*args_, **kwargs_)
        else:
            return description(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='description', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='description')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='description', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='description'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='description', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='description'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'description')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class description


class reporting_org(GeneratedsSuper):
    """The organisation issuing the report. May be a primary source
    (reporting on its own activity as donor, implementing agency,
    etc) or a secondary source (reporting on the activities of
    another organisation). Specifying the @ref attribute is
    mandatory. May contain the organisation name as content. All
    activities in an activity xml file must contain the same @ref
    AND this @ref must be the same as the iati-identifier recorded
    in the registry publisher record of the account under which this
    file is published. Machine-readable identification string for
    the organisation issuing the report. Must be in the format
    {RegistrationAgency}-{RegistrationNumber} where
    {RegistrationAgency} is a valid code in the RegistrationAgency
    code list and {RegistrationNumber } is a valid identifier issued
    by the {RegistrationAgency} The type of organisation issuing the
    report. See IATI codelist for values. A flag indicating that the
    reporting organisation is a secondary publisher: publishing data
    for which it is not directly responsible. This flag must not be
    reported by primary source publishers"""
    subclass = None
    superclass = None
    def __init__(self, type_=None, secondary_reporter=None, ref=None, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.secondary_reporter = _cast(bool, secondary_reporter)
        self.ref = _cast(None, ref)
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if reporting_org.subclass:
            return reporting_org.subclass(*args_, **kwargs_)
        else:
            return reporting_org(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_secondary_reporter(self): return self.secondary_reporter
    def set_secondary_reporter(self, secondary_reporter): self.secondary_reporter = secondary_reporter
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='reporting-org', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='reporting-org')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='reporting-org', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='reporting-org'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.secondary_reporter is not None and 'secondary_reporter' not in already_processed:
            already_processed.add('secondary_reporter')
            outfile.write(' secondary-reporter="%s"' % self.gds_format_boolean(self.secondary_reporter, input_name='secondary-reporter'))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='reporting-org', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='reporting-org'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.secondary_reporter is not None and 'secondary_reporter' not in already_processed:
            already_processed.add('secondary_reporter')
            showIndent(outfile, level)
            outfile.write('secondary_reporter=%s,\n' % (self.secondary_reporter,))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('secondary-reporter', node)
        if value is not None and 'secondary-reporter' not in already_processed:
            already_processed.add('secondary-reporter')
            if value in ('true', '1'):
                self.secondary_reporter = True
            elif value in ('false', '0'):
                self.secondary_reporter = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'reporting-org')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class reporting_org


class textType(GeneratedsSuper):
    """Data type for an element that may contain human-readable text in
    different languages."""
    subclass = None
    superclass = None
    def __init__(self, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if textType.subclass:
            return textType.subclass(*args_, **kwargs_)
        else:
            return textType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='textType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='textType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='textType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='textType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='textType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='textType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'textType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class textType


class textRequiredType(GeneratedsSuper):
    """Data type for an element that must contain human-readable text. The
    information may be repeated in different languages."""
    subclass = None
    superclass = None
    def __init__(self, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if textRequiredType.subclass:
            return textRequiredType.subclass(*args_, **kwargs_)
        else:
            return textRequiredType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='textRequiredType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='textRequiredType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='textRequiredType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='textRequiredType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='textRequiredType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='textRequiredType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'textRequiredType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class textRequiredType


class descriptionType(GeneratedsSuper):
    """The type of description being provided. This is not required if only
    one general description of the activity is reported."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if descriptionType.subclass:
            return descriptionType.subclass(*args_, **kwargs_)
        else:
            return descriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='descriptionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='descriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='descriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='descriptionType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='descriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='descriptionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'descriptionType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class descriptionType


class owner_orgType(GeneratedsSuper):
    """An organisation identifier. This is NOT MANDATORY but when used MUST
    contain a valid organisation identifier."""
    subclass = None
    superclass = None
    def __init__(self, ref=None, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.ref = _cast(None, ref)
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if owner_orgType.subclass:
            return owner_orgType.subclass(*args_, **kwargs_)
        else:
            return owner_orgType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='owner-orgType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='owner-orgType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='owner-orgType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='owner-orgType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='owner-orgType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='owner-orgType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'owner-orgType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class owner_orgType


class telephoneType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if telephoneType.subclass:
            return telephoneType.subclass(*args_, **kwargs_)
        else:
            return telephoneType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='telephoneType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='telephoneType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='telephoneType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='telephoneType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='telephoneType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='telephoneType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class telephoneType


class emailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if emailType.subclass:
            return emailType.subclass(*args_, **kwargs_)
        else:
            return emailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='emailType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='emailType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='emailType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='emailType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='emailType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='emailType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class emailType


class websiteType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if websiteType.subclass:
            return websiteType.subclass(*args_, **kwargs_)
        else:
            return websiteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='websiteType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='websiteType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='websiteType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='websiteType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='websiteType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='websiteType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class websiteType


class transaction_typeType(GeneratedsSuper):
    """An IATI code defining the type of the transaction (e.g. commitment,
    disbursement, expenditure, etc.)."""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if transaction_typeType.subclass:
            return transaction_typeType.subclass(*args_, **kwargs_)
        else:
            return transaction_typeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='transaction-typeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transaction-typeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='transaction-typeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='transaction-typeType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='transaction-typeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='transaction-typeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'transaction-typeType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class transaction_typeType


class transaction_dateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, iso_date=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if isinstance(iso_date, basestring):
            initvalue_ = datetime_.datetime.strptime(iso_date, '%Y-%m-%d').date()
        else:
            initvalue_ = iso_date
        self.iso_date = initvalue_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if transaction_dateType.subclass:
            return transaction_dateType.subclass(*args_, **kwargs_)
        else:
            return transaction_dateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_iso_date(self): return self.iso_date
    def set_iso_date(self, iso_date): self.iso_date = iso_date
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='transaction-dateType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transaction-dateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='transaction-dateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='transaction-dateType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            outfile.write(' iso-date="%s"' % self.gds_format_date(self.iso_date, input_name='iso-date'))
    def exportChildren(self, outfile, level, namespace_='', name_='transaction-dateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='transaction-dateType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            showIndent(outfile, level)
            outfile.write('iso-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.iso_date, input_name='iso-date'))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iso-date', node)
        if value is not None and 'iso-date' not in already_processed:
            already_processed.add('iso-date')
            try:
                self.iso_date = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (iso-date): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'transaction-dateType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class transaction_dateType


class provider_orgType(GeneratedsSuper):
    """Machine-readable identification string for the organisation. Must be
    in the format {Registration Agency} - (Registration Number}
    where {Registration Agency} is a valid code in the Registration
    Agency code list and {Registration Number } is a valid
    identifier issued by the {Registration Agency}. If this is not
    present then the narrative MUST contain the name of the
    organisation. If incoming funds are being provided from the
    budget of another activity that is reported to IATI, it if
    STRONGLY RECOMMENDED that this should record the provider's
    unique IATI activity identifier for that activity."""
    subclass = None
    superclass = None
    def __init__(self, provider_activity_id=None, ref=None, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.provider_activity_id = _cast(None, provider_activity_id)
        self.ref = _cast(None, ref)
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if provider_orgType.subclass:
            return provider_orgType.subclass(*args_, **kwargs_)
        else:
            return provider_orgType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_provider_activity_id(self): return self.provider_activity_id
    def set_provider_activity_id(self, provider_activity_id): self.provider_activity_id = provider_activity_id
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='provider-orgType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='provider-orgType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='provider-orgType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='provider-orgType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.provider_activity_id is not None and 'provider_activity_id' not in already_processed:
            already_processed.add('provider_activity_id')
            outfile.write(' provider-activity-id=%s' % (self.gds_format_string(quote_attrib(self.provider_activity_id).encode(ExternalEncoding), input_name='provider-activity-id'), ))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='provider-orgType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='provider-orgType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.provider_activity_id is not None and 'provider_activity_id' not in already_processed:
            already_processed.add('provider_activity_id')
            showIndent(outfile, level)
            outfile.write('provider_activity_id="%s",\n' % (self.provider_activity_id,))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('provider-activity-id', node)
        if value is not None and 'provider-activity-id' not in already_processed:
            already_processed.add('provider-activity-id')
            self.provider_activity_id = value
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'provider-orgType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class provider_orgType


class receiver_orgType(GeneratedsSuper):
    """Machine-readable identification string for the organisation. Must be
    in the format {Registration Agency} - (Registration Number}
    where {Registration Agency} is a valid code in the Registration
    Agency code list and {Registration Number } is a valid
    identifier issued by the {Registration Agency}. If this is not
    present then the narrative MUST contain the name of the
    organisation. If outgoing funds are being provided to another
    activity that is reported to IATI, this may, if possible, record
    the unique IATI activity identifier for that activity."""
    subclass = None
    superclass = None
    def __init__(self, receiver_activity_id=None, ref=None, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.receiver_activity_id = _cast(None, receiver_activity_id)
        self.ref = _cast(None, ref)
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if receiver_orgType.subclass:
            return receiver_orgType.subclass(*args_, **kwargs_)
        else:
            return receiver_orgType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_receiver_activity_id(self): return self.receiver_activity_id
    def set_receiver_activity_id(self, receiver_activity_id): self.receiver_activity_id = receiver_activity_id
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='receiver-orgType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='receiver-orgType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='receiver-orgType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='receiver-orgType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.receiver_activity_id is not None and 'receiver_activity_id' not in already_processed:
            already_processed.add('receiver_activity_id')
            outfile.write(' receiver-activity-id=%s' % (self.gds_format_string(quote_attrib(self.receiver_activity_id).encode(ExternalEncoding), input_name='receiver-activity-id'), ))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='receiver-orgType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='receiver-orgType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.receiver_activity_id is not None and 'receiver_activity_id' not in already_processed:
            already_processed.add('receiver_activity_id')
            showIndent(outfile, level)
            outfile.write('receiver_activity_id="%s",\n' % (self.receiver_activity_id,))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('receiver-activity-id', node)
        if value is not None and 'receiver-activity-id' not in already_processed:
            already_processed.add('receiver-activity-id')
            self.receiver_activity_id = value
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'receiver-orgType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class receiver_orgType


class disbursement_channelType(GeneratedsSuper):
    """An IATI code defining channels of disbursement"""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if disbursement_channelType.subclass:
            return disbursement_channelType.subclass(*args_, **kwargs_)
        else:
            return disbursement_channelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='disbursement-channelType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='disbursement-channelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='disbursement-channelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='disbursement-channelType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='disbursement-channelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='disbursement-channelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'disbursement-channelType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class disbursement_channelType


class sectorType(GeneratedsSuper):
    """An IATI code for the vocabulary (codelist) used for sector
    classifications. If omitted, OECD DAC 5-digit Purpose Codes are
    assumed. It is recommended that OECD DAC 5-digit Purpose Codes
    are used wherever possible. It is also recommended that if a
    publisher has its own classification system or systems, then the
    vocabularies 99 or 98 (Reporting Organisation's own
    vocabularies) should be used in addition to the DAC codes. Note
    that at transaction level, only one sector per vocabulary can be
    reported. The code for the sector."""
    subclass = None
    superclass = None
    def __init__(self, code=None, vocabulary=None, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        self.vocabulary = _cast(None, vocabulary)
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if sectorType.subclass:
            return sectorType.subclass(*args_, **kwargs_)
        else:
            return sectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='sectorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sectorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='sectorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sectorType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            outfile.write(' vocabulary=%s' % (self.gds_format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='sectorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='sectorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            showIndent(outfile, level)
            outfile.write('vocabulary="%s",\n' % (self.vocabulary,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('vocabulary', node)
        if value is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            self.vocabulary = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'sectorType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class sectorType


class recipient_countryType(GeneratedsSuper):
    """ISO 3166-1 alpha-2 code for the country."""
    subclass = None
    superclass = None
    def __init__(self, code=None, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if recipient_countryType.subclass:
            return recipient_countryType.subclass(*args_, **kwargs_)
        else:
            return recipient_countryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='recipient-countryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='recipient-countryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='recipient-countryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='recipient-countryType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='recipient-countryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='recipient-countryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'recipient-countryType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class recipient_countryType


class recipient_regionType(GeneratedsSuper):
    """Either an OECD DAC or UN region code. Codelist is determined by
    vocabulary attribute. An IATI code for the vocabulary from which
    the region code is drawn. If it is not present 1 - 'OECD DAC' is
    assumed."""
    subclass = None
    superclass = None
    def __init__(self, code=None, vocabulary=None, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        self.vocabulary = _cast(None, vocabulary)
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if recipient_regionType.subclass:
            return recipient_regionType.subclass(*args_, **kwargs_)
        else:
            return recipient_regionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='recipient-regionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='recipient-regionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='recipient-regionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='recipient-regionType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            outfile.write(' vocabulary=%s' % (self.gds_format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='recipient-regionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='recipient-regionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            showIndent(outfile, level)
            outfile.write('vocabulary="%s",\n' % (self.vocabulary,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('vocabulary', node)
        if value is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            self.vocabulary = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'recipient-regionType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class recipient_regionType


class flow_typeType(GeneratedsSuper):
    """A code from the OECD DAC CRS "Type of flow" codelist"""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if flow_typeType.subclass:
            return flow_typeType.subclass(*args_, **kwargs_)
        else:
            return flow_typeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='flow-typeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='flow-typeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='flow-typeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='flow-typeType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='flow-typeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='flow-typeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'flow-typeType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class flow_typeType


class finance_typeType(GeneratedsSuper):
    """A code from the OECD DAC CRS "Type of finance" codelist"""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if finance_typeType.subclass:
            return finance_typeType.subclass(*args_, **kwargs_)
        else:
            return finance_typeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='finance-typeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='finance-typeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='finance-typeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='finance-typeType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='finance-typeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='finance-typeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'finance-typeType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class finance_typeType


class aid_typeType(GeneratedsSuper):
    """A code from the OECD DAC CRS "Type of aid" codelist"""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if aid_typeType.subclass:
            return aid_typeType.subclass(*args_, **kwargs_)
        else:
            return aid_typeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='aid-typeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='aid-typeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='aid-typeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='aid-typeType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='aid-typeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='aid-typeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'aid-typeType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class aid_typeType


class tied_statusType(GeneratedsSuper):
    """An IATI code interpreting the usage of Columns 36-38 of the CRS++
    reporting format. (Amount tied, Amount partially untied, Amount
    tied)"""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if tied_statusType.subclass:
            return tied_statusType.subclass(*args_, **kwargs_)
        else:
            return tied_statusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tied-statusType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tied-statusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tied-statusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tied-statusType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='tied-statusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='tied-statusType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'tied-statusType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class tied_statusType


class location_reachType(GeneratedsSuper):
    """An IATI code for the geographic scope of the activity."""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if location_reachType.subclass:
            return location_reachType.subclass(*args_, **kwargs_)
        else:
            return location_reachType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='location-reachType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='location-reachType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='location-reachType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='location-reachType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='location-reachType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='location-reachType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'location-reachType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class location_reachType


class location_idType(GeneratedsSuper):
    """A code from the gazetteer or administrative boundary repository
    specified by the vocabulary An IATI code for a recognised
    gazetteer or administrative boundary respository."""
    subclass = None
    superclass = None
    def __init__(self, code=None, vocabulary=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        self.vocabulary = _cast(None, vocabulary)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if location_idType.subclass:
            return location_idType.subclass(*args_, **kwargs_)
        else:
            return location_idType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='location-idType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='location-idType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='location-idType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='location-idType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            outfile.write(' vocabulary=%s' % (self.gds_format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='location-idType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='location-idType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            showIndent(outfile, level)
            outfile.write('vocabulary="%s",\n' % (self.vocabulary,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('vocabulary', node)
        if value is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            self.vocabulary = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'location-idType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class location_idType


class administrativeType(GeneratedsSuper):
    """The code for the administrative area being reported from the
    vocabulary specified. An IATI code for a recognised
    administrative boundary repository. A number defining a
    subdivision within a hierarchical system of administrative
    areas. The precise system for defining the particular meaning of
    each @level value is determined by the @vocabulary being used."""
    subclass = None
    superclass = None
    def __init__(self, code=None, vocabulary=None, level=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        self.vocabulary = _cast(None, vocabulary)
        self.level = _cast(int, level)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if administrativeType.subclass:
            return administrativeType.subclass(*args_, **kwargs_)
        else:
            return administrativeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='administrativeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='administrativeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='administrativeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='administrativeType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            outfile.write(' vocabulary=%s' % (self.gds_format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
        if self.level is not None and 'level' not in already_processed:
            already_processed.add('level')
            outfile.write(' level="%s"' % self.gds_format_integer(self.level, input_name='level'))
    def exportChildren(self, outfile, level, namespace_='', name_='administrativeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='administrativeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            showIndent(outfile, level)
            outfile.write('vocabulary="%s",\n' % (self.vocabulary,))
        if self.level is not None and 'level' not in already_processed:
            already_processed.add('level')
            showIndent(outfile, level)
            outfile.write('level=%d,\n' % (self.level,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('vocabulary', node)
        if value is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            self.vocabulary = value
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.add('level')
            try:
                self.level = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.level < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'administrativeType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class administrativeType


class pointType(GeneratedsSuper):
    """The name of the spatial reference system used by the coordinates.
    Always: http://www.opengis.net/def/crs/EPSG/0/4326"""
    subclass = None
    superclass = None
    def __init__(self, srsName=None, pos=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.srsName = _cast(None, srsName)
        self.pos = pos
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if pointType.subclass:
            return pointType.subclass(*args_, **kwargs_)
        else:
            return pointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_srsName(self): return self.srsName
    def set_srsName(self, srsName): self.srsName = srsName
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.pos is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='pointType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='pointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pointType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.srsName is not None and 'srsName' not in already_processed:
            already_processed.add('srsName')
            outfile.write(' srsName=%s' % (self.gds_format_string(quote_attrib(self.srsName).encode(ExternalEncoding), input_name='srsName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='pointType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pos is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spos>%s</%spos>%s' % (namespace_, self.gds_format_string(quote_xml(self.pos).encode(ExternalEncoding), input_name='pos'), namespace_, eol_))
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='pointType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.srsName is not None and 'srsName' not in already_processed:
            already_processed.add('srsName')
            showIndent(outfile, level)
            outfile.write('srsName="%s",\n' % (self.srsName,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.pos is not None:
            showIndent(outfile, level)
            outfile.write('pos=%s,\n' % quote_python(self.pos).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('srsName', node)
        if value is not None and 'srsName' not in already_processed:
            already_processed.add('srsName')
            self.srsName = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pos':
            pos_ = child_.text
            pos_ = self.gds_validate_string(pos_, node, 'pos')
            self.pos = pos_
        else:
            obj_ = self.gds_build_any(child_, 'pointType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class pointType


class exactnessType(GeneratedsSuper):
    """A code from the Geographic Exactness Codelist."""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if exactnessType.subclass:
            return exactnessType.subclass(*args_, **kwargs_)
        else:
            return exactnessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exactnessType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exactnessType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exactnessType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exactnessType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='exactnessType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='exactnessType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'exactnessType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class exactnessType


class location_classType(GeneratedsSuper):
    """A code from the Location Class codelist"""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if location_classType.subclass:
            return location_classType.subclass(*args_, **kwargs_)
        else:
            return location_classType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='location-classType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='location-classType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='location-classType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='location-classType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='location-classType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='location-classType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'location-classType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class location_classType


class feature_designationType(GeneratedsSuper):
    """A feature designation code form the authorised list (maintained by
    the US National Geospatial-Intelligence Agency)"""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if feature_designationType.subclass:
            return feature_designationType.subclass(*args_, **kwargs_)
        else:
            return feature_designationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='feature-designationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='feature-designationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='feature-designationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='feature-designationType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='feature-designationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='feature-designationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'feature-designationType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class feature_designationType


class budget_itemType(GeneratedsSuper):
    """A code for the budget-item from the vocabulary specified. When
    multiple budget-item elements are declared within a single
    country-budget-items element, then, for each vocabulary used,
    the percentage values should sum 100%."""
    subclass = None
    superclass = None
    def __init__(self, percentage=None, code=None, description=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.percentage = _cast(float, percentage)
        self.code = _cast(None, code)
        self.description = description
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if budget_itemType.subclass:
            return budget_itemType.subclass(*args_, **kwargs_)
        else:
            return budget_itemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_percentage(self): return self.percentage
    def set_percentage(self, percentage): self.percentage = percentage
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.description is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='budget-itemType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='budget-itemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='budget-itemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='budget-itemType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            outfile.write(' percentage="%s"' % self.gds_format_float(self.percentage, input_name='percentage'))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='budget-itemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='budget-itemType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            showIndent(outfile, level)
            outfile.write('percentage=%f,\n' % (self.percentage,))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.textRequiredType(\n')
            self.description.exportLiteral(outfile, level, name_='description')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('percentage', node)
        if value is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            try:
                self.percentage = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (percentage): %s' % exp)
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = textRequiredType.factory()
            obj_.build(child_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        else:
            obj_ = self.gds_build_any(child_, 'budget-itemType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class budget_itemType


class indicatorType(GeneratedsSuper):
    """An IATI code defining the unit of measure in which the value is
    reported. A boolean describing the behaviour of the indicator.
    It is "true" if the indicator improves from small to large (e.g.
    clinics built); false if it improves from large to small (e.g.
    cases of a disease)."""
    subclass = None
    superclass = None
    def __init__(self, ascending=None, measure=None, title=None, description=None, baseline=None, period=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.ascending = _cast(bool, ascending)
        self.measure = _cast(None, measure)
        self.title = title
        self.description = description
        self.baseline = baseline
        if period is None:
            self.period = []
        else:
            self.period = period
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if indicatorType.subclass:
            return indicatorType.subclass(*args_, **kwargs_)
        else:
            return indicatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_baseline(self): return self.baseline
    def set_baseline(self, baseline): self.baseline = baseline
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def add_period(self, value): self.period.append(value)
    def insert_period_at(self, index, value): self.period.insert(index, value)
    def replace_period_at(self, index, value): self.period[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_ascending(self): return self.ascending
    def set_ascending(self, ascending): self.ascending = ascending
    def get_measure(self): return self.measure
    def set_measure(self, measure): self.measure = measure
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.title is not None or
            self.description is not None or
            self.baseline is not None or
            self.period or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indicatorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indicatorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indicatorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indicatorType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ascending is not None and 'ascending' not in already_processed:
            already_processed.add('ascending')
            outfile.write(' ascending="%s"' % self.gds_format_boolean(self.ascending, input_name='ascending'))
        if self.measure is not None and 'measure' not in already_processed:
            already_processed.add('measure')
            outfile.write(' measure=%s' % (self.gds_format_string(quote_attrib(self.measure).encode(ExternalEncoding), input_name='measure'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='indicatorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            self.title.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
        if self.baseline is not None:
            self.baseline.export(outfile, level, namespace_, name_='baseline', pretty_print=pretty_print)
        for period_ in self.period:
            period_.export(outfile, level, namespace_, name_='period', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='indicatorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ascending is not None and 'ascending' not in already_processed:
            already_processed.add('ascending')
            showIndent(outfile, level)
            outfile.write('ascending=%s,\n' % (self.ascending,))
        if self.measure is not None and 'measure' not in already_processed:
            already_processed.add('measure')
            showIndent(outfile, level)
            outfile.write('measure="%s",\n' % (self.measure,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('title=model_.title(\n')
            self.title.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.baseline is not None:
            showIndent(outfile, level)
            outfile.write('baseline=model_.baselineType(\n')
            self.baseline.exportLiteral(outfile, level, name_='baseline')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('period=[\n')
        level += 1
        for period_ in self.period:
            showIndent(outfile, level)
            outfile.write('model_.periodType(\n')
            period_.exportLiteral(outfile, level, name_='periodType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ascending', node)
        if value is not None and 'ascending' not in already_processed:
            already_processed.add('ascending')
            if value in ('true', '1'):
                self.ascending = True
            elif value in ('false', '0'):
                self.ascending = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('measure', node)
        if value is not None and 'measure' not in already_processed:
            already_processed.add('measure')
            self.measure = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            obj_ = textRequiredType.factory()
            obj_.build(child_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'baseline':
            obj_ = baselineType.factory()
            obj_.build(child_)
            self.baseline = obj_
            obj_.original_tagname_ = 'baseline'
        elif nodeName_ == 'period':
            obj_ = periodType.factory()
            obj_.build(child_)
            self.period.append(obj_)
            obj_.original_tagname_ = 'period'
        else:
            obj_ = self.gds_build_any(child_, 'indicatorType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class indicatorType


class baselineType(GeneratedsSuper):
    """The year the baseline value was taken (yyyy) The baseline value."""
    subclass = None
    superclass = None
    def __init__(self, value=None, year=None, comment=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.year = _cast(int, year)
        self.comment = comment
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if baselineType.subclass:
            return baselineType.subclass(*args_, **kwargs_)
        else:
            return baselineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_year(self): return self.year
    def set_year(self, year): self.year = year
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.comment is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='baselineType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='baselineType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='baselineType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='baselineType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            outfile.write(' year="%s"' % self.gds_format_integer(self.year, input_name='year'))
    def exportChildren(self, outfile, level, namespace_='', name_='baselineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.comment is not None:
            self.comment.export(outfile, level, namespace_, name_='comment', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='baselineType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            showIndent(outfile, level)
            outfile.write('year=%d,\n' % (self.year,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=model_.comment(\n')
            self.comment.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('year', node)
        if value is not None and 'year' not in already_processed:
            already_processed.add('year')
            try:
                self.year = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.year <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'comment':
            obj_ = textRequiredType.factory()
            obj_.build(child_)
            self.comment = obj_
            obj_.original_tagname_ = 'comment'
        else:
            obj_ = self.gds_build_any(child_, 'baselineType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class baselineType


class periodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, period_start=None, period_end=None, target=None, actual=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.period_start = period_start
        self.period_end = period_end
        self.target = target
        self.actual = actual
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if periodType.subclass:
            return periodType.subclass(*args_, **kwargs_)
        else:
            return periodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_period_start(self): return self.period_start
    def set_period_start(self, period_start): self.period_start = period_start
    def get_period_end(self): return self.period_end
    def set_period_end(self, period_end): self.period_end = period_end
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def get_actual(self): return self.actual
    def set_actual(self, actual): self.actual = actual
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.period_start is not None or
            self.period_end is not None or
            self.target is not None or
            self.actual is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='periodType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='periodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='periodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='periodType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='periodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.period_start is not None:
            self.period_start.export(outfile, level, namespace_, name_='period-start', pretty_print=pretty_print)
        if self.period_end is not None:
            self.period_end.export(outfile, level, namespace_, name_='period-end', pretty_print=pretty_print)
        if self.target is not None:
            self.target.export(outfile, level, namespace_, name_='target', pretty_print=pretty_print)
        if self.actual is not None:
            self.actual.export(outfile, level, namespace_, name_='actual', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='periodType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.period_start is not None:
            showIndent(outfile, level)
            outfile.write('period_start=model_.period_startType(\n')
            self.period_start.exportLiteral(outfile, level, name_='period_start')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.period_end is not None:
            showIndent(outfile, level)
            outfile.write('period_end=model_.period_endType(\n')
            self.period_end.exportLiteral(outfile, level, name_='period_end')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.target is not None:
            showIndent(outfile, level)
            outfile.write('target=model_.targetType(\n')
            self.target.exportLiteral(outfile, level, name_='target')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.actual is not None:
            showIndent(outfile, level)
            outfile.write('actual=model_.actualType(\n')
            self.actual.exportLiteral(outfile, level, name_='actual')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'period-start':
            obj_ = period_startType.factory()
            obj_.build(child_)
            self.period_start = obj_
            obj_.original_tagname_ = 'period-start'
        elif nodeName_ == 'period-end':
            obj_ = period_endType.factory()
            obj_.build(child_)
            self.period_end = obj_
            obj_.original_tagname_ = 'period-end'
        elif nodeName_ == 'target':
            obj_ = targetType.factory()
            obj_.build(child_)
            self.target = obj_
            obj_.original_tagname_ = 'target'
        elif nodeName_ == 'actual':
            obj_ = actualType.factory()
            obj_.build(child_)
            self.actual = obj_
            obj_.original_tagname_ = 'actual'
        else:
            obj_ = self.gds_build_any(child_, 'periodType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class periodType


class period_startType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, iso_date=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if isinstance(iso_date, basestring):
            initvalue_ = datetime_.datetime.strptime(iso_date, '%Y-%m-%d').date()
        else:
            initvalue_ = iso_date
        self.iso_date = initvalue_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if period_startType.subclass:
            return period_startType.subclass(*args_, **kwargs_)
        else:
            return period_startType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_iso_date(self): return self.iso_date
    def set_iso_date(self, iso_date): self.iso_date = iso_date
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='period-startType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='period-startType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='period-startType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='period-startType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            outfile.write(' iso-date="%s"' % self.gds_format_date(self.iso_date, input_name='iso-date'))
    def exportChildren(self, outfile, level, namespace_='', name_='period-startType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='period-startType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            showIndent(outfile, level)
            outfile.write('iso-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.iso_date, input_name='iso-date'))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iso-date', node)
        if value is not None and 'iso-date' not in already_processed:
            already_processed.add('iso-date')
            try:
                self.iso_date = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (iso-date): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'period-startType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class period_startType


class period_endType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, iso_date=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if isinstance(iso_date, basestring):
            initvalue_ = datetime_.datetime.strptime(iso_date, '%Y-%m-%d').date()
        else:
            initvalue_ = iso_date
        self.iso_date = initvalue_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if period_endType.subclass:
            return period_endType.subclass(*args_, **kwargs_)
        else:
            return period_endType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_iso_date(self): return self.iso_date
    def set_iso_date(self, iso_date): self.iso_date = iso_date
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='period-endType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='period-endType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='period-endType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='period-endType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            outfile.write(' iso-date="%s"' % self.gds_format_date(self.iso_date, input_name='iso-date'))
    def exportChildren(self, outfile, level, namespace_='', name_='period-endType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='period-endType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            showIndent(outfile, level)
            outfile.write('iso-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.iso_date, input_name='iso-date'))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iso-date', node)
        if value is not None and 'iso-date' not in already_processed:
            already_processed.add('iso-date')
            try:
                self.iso_date = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (iso-date): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'period-endType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class period_endType


class targetType(GeneratedsSuper):
    """The target value."""
    subclass = None
    superclass = None
    def __init__(self, value=None, comment=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.comment = comment
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if targetType.subclass:
            return targetType.subclass(*args_, **kwargs_)
        else:
            return targetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.comment is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='targetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='targetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='targetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='targetType'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='targetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.comment is not None:
            self.comment.export(outfile, level, namespace_, name_='comment', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='targetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=model_.comment(\n')
            self.comment.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'comment':
            obj_ = textRequiredType.factory()
            obj_.build(child_)
            self.comment = obj_
            obj_.original_tagname_ = 'comment'
        else:
            obj_ = self.gds_build_any(child_, 'targetType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class targetType


class actualType(GeneratedsSuper):
    """The actual measure."""
    subclass = None
    superclass = None
    def __init__(self, value=None, comment=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.comment = comment
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if actualType.subclass:
            return actualType.subclass(*args_, **kwargs_)
        else:
            return actualType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.comment is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='actualType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='actualType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='actualType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='actualType'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='actualType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.comment is not None:
            self.comment.export(outfile, level, namespace_, name_='comment', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='actualType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=model_.comment(\n')
            self.comment.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'comment':
            obj_ = textRequiredType.factory()
            obj_.build(child_)
            self.comment = obj_
            obj_.original_tagname_ = 'comment'
        else:
            obj_ = self.gds_build_any(child_, 'actualType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class actualType


class conditionType(GeneratedsSuper):
    """An IATI code defining the type of condition."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, narrative=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        if narrative is None:
            self.narrative = []
        else:
            self.narrative = narrative
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if conditionType.subclass:
            return conditionType.subclass(*args_, **kwargs_)
        else:
            return conditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def add_narrative(self, value): self.narrative.append(value)
    def insert_narrative_at(self, index, value): self.narrative.insert(index, value)
    def replace_narrative_at(self, index, value): self.narrative[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.narrative or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='conditionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='conditionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='conditionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='conditionType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='conditionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for narrative_ in self.narrative:
            narrative_.export(outfile, level, namespace_, name_='narrative', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='conditionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('narrative=[\n')
        level += 1
        for narrative_ in self.narrative:
            showIndent(outfile, level)
            outfile.write('model_.narrative(\n')
            narrative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'narrative':
            obj_ = narrative.factory()
            obj_.build(child_)
            self.narrative.append(obj_)
            obj_.original_tagname_ = 'narrative'
        else:
            obj_ = self.gds_build_any(child_, 'conditionType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class conditionType


class period_startType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, iso_date=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if isinstance(iso_date, basestring):
            initvalue_ = datetime_.datetime.strptime(iso_date, '%Y-%m-%d').date()
        else:
            initvalue_ = iso_date
        self.iso_date = initvalue_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if period_startType1.subclass:
            return period_startType1.subclass(*args_, **kwargs_)
        else:
            return period_startType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_iso_date(self): return self.iso_date
    def set_iso_date(self, iso_date): self.iso_date = iso_date
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='period-startType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='period-startType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='period-startType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='period-startType1'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            outfile.write(' iso-date="%s"' % self.gds_format_date(self.iso_date, input_name='iso-date'))
    def exportChildren(self, outfile, level, namespace_='', name_='period-startType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='period-startType1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            showIndent(outfile, level)
            outfile.write('iso-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.iso_date, input_name='iso-date'))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iso-date', node)
        if value is not None and 'iso-date' not in already_processed:
            already_processed.add('iso-date')
            try:
                self.iso_date = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (iso-date): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'period-startType1')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class period_startType1


class period_endType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, iso_date=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if isinstance(iso_date, basestring):
            initvalue_ = datetime_.datetime.strptime(iso_date, '%Y-%m-%d').date()
        else:
            initvalue_ = iso_date
        self.iso_date = initvalue_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if period_endType2.subclass:
            return period_endType2.subclass(*args_, **kwargs_)
        else:
            return period_endType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_iso_date(self): return self.iso_date
    def set_iso_date(self, iso_date): self.iso_date = iso_date
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='period-endType2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='period-endType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='period-endType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='period-endType2'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            outfile.write(' iso-date="%s"' % self.gds_format_date(self.iso_date, input_name='iso-date'))
    def exportChildren(self, outfile, level, namespace_='', name_='period-endType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='period-endType2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            showIndent(outfile, level)
            outfile.write('iso-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.iso_date, input_name='iso-date'))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iso-date', node)
        if value is not None and 'iso-date' not in already_processed:
            already_processed.add('iso-date')
            try:
                self.iso_date = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (iso-date): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'period-endType2')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class period_endType2


class period_startType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, iso_date=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if isinstance(iso_date, basestring):
            initvalue_ = datetime_.datetime.strptime(iso_date, '%Y-%m-%d').date()
        else:
            initvalue_ = iso_date
        self.iso_date = initvalue_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if period_startType3.subclass:
            return period_startType3.subclass(*args_, **kwargs_)
        else:
            return period_startType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_iso_date(self): return self.iso_date
    def set_iso_date(self, iso_date): self.iso_date = iso_date
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='period-startType3', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='period-startType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='period-startType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='period-startType3'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            outfile.write(' iso-date="%s"' % self.gds_format_date(self.iso_date, input_name='iso-date'))
    def exportChildren(self, outfile, level, namespace_='', name_='period-startType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='period-startType3'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            showIndent(outfile, level)
            outfile.write('iso-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.iso_date, input_name='iso-date'))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iso-date', node)
        if value is not None and 'iso-date' not in already_processed:
            already_processed.add('iso-date')
            try:
                self.iso_date = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (iso-date): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'period-startType3')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class period_startType3


class period_endType4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, iso_date=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if isinstance(iso_date, basestring):
            initvalue_ = datetime_.datetime.strptime(iso_date, '%Y-%m-%d').date()
        else:
            initvalue_ = iso_date
        self.iso_date = initvalue_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if period_endType4.subclass:
            return period_endType4.subclass(*args_, **kwargs_)
        else:
            return period_endType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_iso_date(self): return self.iso_date
    def set_iso_date(self, iso_date): self.iso_date = iso_date
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='period-endType4', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='period-endType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='period-endType4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='period-endType4'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            outfile.write(' iso-date="%s"' % self.gds_format_date(self.iso_date, input_name='iso-date'))
    def exportChildren(self, outfile, level, namespace_='', name_='period-endType4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='period-endType4'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            showIndent(outfile, level)
            outfile.write('iso-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.iso_date, input_name='iso-date'))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iso-date', node)
        if value is not None and 'iso-date' not in already_processed:
            already_processed.add('iso-date')
            try:
                self.iso_date = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (iso-date): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'period-endType4')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class period_endType4


class other_flagsType(GeneratedsSuper):
    """An IATI code describing the equivalent CRS++ columns A boolean
    indicating whether the flag applies. If 'false' do not report
    the flag"""
    subclass = None
    superclass = None
    def __init__(self, code=None, significance=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        self.significance = _cast(bool, significance)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if other_flagsType.subclass:
            return other_flagsType.subclass(*args_, **kwargs_)
        else:
            return other_flagsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_significance(self): return self.significance
    def set_significance(self, significance): self.significance = significance
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='other-flagsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='other-flagsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='other-flagsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='other-flagsType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
        if self.significance is not None and 'significance' not in already_processed:
            already_processed.add('significance')
            outfile.write(' significance="%s"' % self.gds_format_boolean(self.significance, input_name='significance'))
    def exportChildren(self, outfile, level, namespace_='', name_='other-flagsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='other-flagsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        if self.significance is not None and 'significance' not in already_processed:
            already_processed.add('significance')
            showIndent(outfile, level)
            outfile.write('significance=%s,\n' % (self.significance,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('significance', node)
        if value is not None and 'significance' not in already_processed:
            already_processed.add('significance')
            if value in ('true', '1'):
                self.significance = True
            elif value in ('false', '0'):
                self.significance = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'other-flagsType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class other_flagsType


class loan_termsType(GeneratedsSuper):
    """Interest Rate. If an ODA loan with variable interest rate, report
    the variable rate here and the reference fixed rate as rate-2
    Enter the rate without the percentage sign. Second Interest
    Rate. If an ODA loan with variable interest rate, report the
    variable rate as rate-1 and the reference fixed rate here Enter
    the rate without the percentage sign."""
    subclass = None
    superclass = None
    def __init__(self, rate_2=None, rate_1=None, repayment_type=None, repayment_plan=None, commitment_date=None, repayment_first_date=None, repayment_final_date=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.rate_2 = _cast(float, rate_2)
        self.rate_1 = _cast(float, rate_1)
        self.repayment_type = repayment_type
        self.repayment_plan = repayment_plan
        self.commitment_date = commitment_date
        self.repayment_first_date = repayment_first_date
        self.repayment_final_date = repayment_final_date
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if loan_termsType.subclass:
            return loan_termsType.subclass(*args_, **kwargs_)
        else:
            return loan_termsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_repayment_type(self): return self.repayment_type
    def set_repayment_type(self, repayment_type): self.repayment_type = repayment_type
    def get_repayment_plan(self): return self.repayment_plan
    def set_repayment_plan(self, repayment_plan): self.repayment_plan = repayment_plan
    def get_commitment_date(self): return self.commitment_date
    def set_commitment_date(self, commitment_date): self.commitment_date = commitment_date
    def get_repayment_first_date(self): return self.repayment_first_date
    def set_repayment_first_date(self, repayment_first_date): self.repayment_first_date = repayment_first_date
    def get_repayment_final_date(self): return self.repayment_final_date
    def set_repayment_final_date(self, repayment_final_date): self.repayment_final_date = repayment_final_date
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_rate_2(self): return self.rate_2
    def set_rate_2(self, rate_2): self.rate_2 = rate_2
    def get_rate_1(self): return self.rate_1
    def set_rate_1(self, rate_1): self.rate_1 = rate_1
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.repayment_type is not None or
            self.repayment_plan is not None or
            self.commitment_date is not None or
            self.repayment_first_date is not None or
            self.repayment_final_date is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='loan-termsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='loan-termsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='loan-termsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='loan-termsType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.rate_2 is not None and 'rate_2' not in already_processed:
            already_processed.add('rate_2')
            outfile.write(' rate-2="%s"' % self.gds_format_float(self.rate_2, input_name='rate-2'))
        if self.rate_1 is not None and 'rate_1' not in already_processed:
            already_processed.add('rate_1')
            outfile.write(' rate-1="%s"' % self.gds_format_float(self.rate_1, input_name='rate-1'))
    def exportChildren(self, outfile, level, namespace_='', name_='loan-termsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.repayment_type is not None:
            self.repayment_type.export(outfile, level, namespace_, name_='repayment-type', pretty_print=pretty_print)
        if self.repayment_plan is not None:
            self.repayment_plan.export(outfile, level, namespace_, name_='repayment-plan', pretty_print=pretty_print)
        if self.commitment_date is not None:
            self.commitment_date.export(outfile, level, namespace_, name_='commitment-date', pretty_print=pretty_print)
        if self.repayment_first_date is not None:
            self.repayment_first_date.export(outfile, level, namespace_, name_='repayment-first-date', pretty_print=pretty_print)
        if self.repayment_final_date is not None:
            self.repayment_final_date.export(outfile, level, namespace_, name_='repayment-final-date', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='loan-termsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rate_2 is not None and 'rate_2' not in already_processed:
            already_processed.add('rate_2')
            showIndent(outfile, level)
            outfile.write('rate_2=%f,\n' % (self.rate_2,))
        if self.rate_1 is not None and 'rate_1' not in already_processed:
            already_processed.add('rate_1')
            showIndent(outfile, level)
            outfile.write('rate_1=%f,\n' % (self.rate_1,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.repayment_type is not None:
            showIndent(outfile, level)
            outfile.write('repayment_type=model_.repayment_typeType(\n')
            self.repayment_type.exportLiteral(outfile, level, name_='repayment_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.repayment_plan is not None:
            showIndent(outfile, level)
            outfile.write('repayment_plan=model_.repayment_planType(\n')
            self.repayment_plan.exportLiteral(outfile, level, name_='repayment_plan')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.commitment_date is not None:
            showIndent(outfile, level)
            outfile.write('commitment_date=model_.commitment_dateType(\n')
            self.commitment_date.exportLiteral(outfile, level, name_='commitment_date')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.repayment_first_date is not None:
            showIndent(outfile, level)
            outfile.write('repayment_first_date=model_.repayment_first_dateType(\n')
            self.repayment_first_date.exportLiteral(outfile, level, name_='repayment_first_date')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.repayment_final_date is not None:
            showIndent(outfile, level)
            outfile.write('repayment_final_date=model_.repayment_final_dateType(\n')
            self.repayment_final_date.exportLiteral(outfile, level, name_='repayment_final_date')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rate-2', node)
        if value is not None and 'rate-2' not in already_processed:
            already_processed.add('rate-2')
            try:
                self.rate_2 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rate-2): %s' % exp)
        value = find_attr_value_('rate-1', node)
        if value is not None and 'rate-1' not in already_processed:
            already_processed.add('rate-1')
            try:
                self.rate_1 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rate-1): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'repayment-type':
            obj_ = repayment_typeType.factory()
            obj_.build(child_)
            self.repayment_type = obj_
            obj_.original_tagname_ = 'repayment-type'
        elif nodeName_ == 'repayment-plan':
            obj_ = repayment_planType.factory()
            obj_.build(child_)
            self.repayment_plan = obj_
            obj_.original_tagname_ = 'repayment-plan'
        elif nodeName_ == 'commitment-date':
            obj_ = commitment_dateType.factory()
            obj_.build(child_)
            self.commitment_date = obj_
            obj_.original_tagname_ = 'commitment-date'
        elif nodeName_ == 'repayment-first-date':
            obj_ = repayment_first_dateType.factory()
            obj_.build(child_)
            self.repayment_first_date = obj_
            obj_.original_tagname_ = 'repayment-first-date'
        elif nodeName_ == 'repayment-final-date':
            obj_ = repayment_final_dateType.factory()
            obj_.build(child_)
            self.repayment_final_date = obj_
            obj_.original_tagname_ = 'repayment-final-date'
        else:
            obj_ = self.gds_build_any(child_, 'loan-termsType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class loan_termsType


class repayment_typeType(GeneratedsSuper):
    """An IATI codelist tabulating CRS-specified values for the type of
    Repayment."""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if repayment_typeType.subclass:
            return repayment_typeType.subclass(*args_, **kwargs_)
        else:
            return repayment_typeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='repayment-typeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='repayment-typeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='repayment-typeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='repayment-typeType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='repayment-typeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='repayment-typeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'repayment-typeType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class repayment_typeType


class repayment_planType(GeneratedsSuper):
    """An IATI codelist tabulating CRS-specified values for the number of
    repayments per annum."""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if repayment_planType.subclass:
            return repayment_planType.subclass(*args_, **kwargs_)
        else:
            return repayment_planType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='repayment-planType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='repayment-planType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='repayment-planType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='repayment-planType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='repayment-planType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='repayment-planType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'repayment-planType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class repayment_planType


class commitment_dateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, iso_date=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if isinstance(iso_date, basestring):
            initvalue_ = datetime_.datetime.strptime(iso_date, '%Y-%m-%d').date()
        else:
            initvalue_ = iso_date
        self.iso_date = initvalue_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if commitment_dateType.subclass:
            return commitment_dateType.subclass(*args_, **kwargs_)
        else:
            return commitment_dateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_iso_date(self): return self.iso_date
    def set_iso_date(self, iso_date): self.iso_date = iso_date
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='commitment-dateType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='commitment-dateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='commitment-dateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='commitment-dateType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            outfile.write(' iso-date="%s"' % self.gds_format_date(self.iso_date, input_name='iso-date'))
    def exportChildren(self, outfile, level, namespace_='', name_='commitment-dateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='commitment-dateType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            showIndent(outfile, level)
            outfile.write('iso-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.iso_date, input_name='iso-date'))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iso-date', node)
        if value is not None and 'iso-date' not in already_processed:
            already_processed.add('iso-date')
            try:
                self.iso_date = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (iso-date): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'commitment-dateType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class commitment_dateType


class repayment_first_dateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, iso_date=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if isinstance(iso_date, basestring):
            initvalue_ = datetime_.datetime.strptime(iso_date, '%Y-%m-%d').date()
        else:
            initvalue_ = iso_date
        self.iso_date = initvalue_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if repayment_first_dateType.subclass:
            return repayment_first_dateType.subclass(*args_, **kwargs_)
        else:
            return repayment_first_dateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_iso_date(self): return self.iso_date
    def set_iso_date(self, iso_date): self.iso_date = iso_date
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='repayment-first-dateType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='repayment-first-dateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='repayment-first-dateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='repayment-first-dateType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            outfile.write(' iso-date="%s"' % self.gds_format_date(self.iso_date, input_name='iso-date'))
    def exportChildren(self, outfile, level, namespace_='', name_='repayment-first-dateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='repayment-first-dateType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            showIndent(outfile, level)
            outfile.write('iso-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.iso_date, input_name='iso-date'))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iso-date', node)
        if value is not None and 'iso-date' not in already_processed:
            already_processed.add('iso-date')
            try:
                self.iso_date = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (iso-date): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'repayment-first-dateType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class repayment_first_dateType


class repayment_final_dateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, iso_date=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if isinstance(iso_date, basestring):
            initvalue_ = datetime_.datetime.strptime(iso_date, '%Y-%m-%d').date()
        else:
            initvalue_ = iso_date
        self.iso_date = initvalue_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if repayment_final_dateType.subclass:
            return repayment_final_dateType.subclass(*args_, **kwargs_)
        else:
            return repayment_final_dateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_iso_date(self): return self.iso_date
    def set_iso_date(self, iso_date): self.iso_date = iso_date
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='repayment-final-dateType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='repayment-final-dateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='repayment-final-dateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='repayment-final-dateType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            outfile.write(' iso-date="%s"' % self.gds_format_date(self.iso_date, input_name='iso-date'))
    def exportChildren(self, outfile, level, namespace_='', name_='repayment-final-dateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='repayment-final-dateType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            showIndent(outfile, level)
            outfile.write('iso-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.iso_date, input_name='iso-date'))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iso-date', node)
        if value is not None and 'iso-date' not in already_processed:
            already_processed.add('iso-date')
            try:
                self.iso_date = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (iso-date): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'repayment-final-dateType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class repayment_final_dateType


class loan_statusType(GeneratedsSuper):
    """CRS Reporting Year (CRS++ Column 1)"""
    subclass = None
    superclass = None
    def __init__(self, currency=None, value_date=None, year=None, interest_received=None, principal_outstanding=None, principal_arrears=None, interest_arrears=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.currency = _cast(None, currency)
        if isinstance(value_date, basestring):
            initvalue_ = datetime_.datetime.strptime(value_date, '%Y-%m-%d').date()
        else:
            initvalue_ = value_date
        self.value_date = initvalue_
        self.year = _cast(float, year)
        self.interest_received = interest_received
        self.principal_outstanding = principal_outstanding
        self.principal_arrears = principal_arrears
        self.interest_arrears = interest_arrears
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if loan_statusType.subclass:
            return loan_statusType.subclass(*args_, **kwargs_)
        else:
            return loan_statusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_interest_received(self): return self.interest_received
    def set_interest_received(self, interest_received): self.interest_received = interest_received
    def get_principal_outstanding(self): return self.principal_outstanding
    def set_principal_outstanding(self, principal_outstanding): self.principal_outstanding = principal_outstanding
    def get_principal_arrears(self): return self.principal_arrears
    def set_principal_arrears(self, principal_arrears): self.principal_arrears = principal_arrears
    def get_interest_arrears(self): return self.interest_arrears
    def set_interest_arrears(self, interest_arrears): self.interest_arrears = interest_arrears
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_value_date(self): return self.value_date
    def set_value_date(self, value_date): self.value_date = value_date
    def get_year(self): return self.year
    def set_year(self, year): self.year = year
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.interest_received is not None or
            self.principal_outstanding is not None or
            self.principal_arrears is not None or
            self.interest_arrears is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='loan-statusType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='loan-statusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='loan-statusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='loan-statusType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            outfile.write(' currency=%s' % (self.gds_format_string(quote_attrib(self.currency).encode(ExternalEncoding), input_name='currency'), ))
        if self.value_date is not None and 'value_date' not in already_processed:
            already_processed.add('value_date')
            outfile.write(' value-date="%s"' % self.gds_format_date(self.value_date, input_name='value-date'))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            outfile.write(' year="%s"' % self.gds_format_float(self.year, input_name='year'))
    def exportChildren(self, outfile, level, namespace_='', name_='loan-statusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.interest_received is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterest-received>%s</%sinterest-received>%s' % (namespace_, self.gds_format_float(self.interest_received, input_name='interest-received'), namespace_, eol_))
        if self.principal_outstanding is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprincipal-outstanding>%s</%sprincipal-outstanding>%s' % (namespace_, self.gds_format_float(self.principal_outstanding, input_name='principal-outstanding'), namespace_, eol_))
        if self.principal_arrears is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprincipal-arrears>%s</%sprincipal-arrears>%s' % (namespace_, self.gds_format_float(self.principal_arrears, input_name='principal-arrears'), namespace_, eol_))
        if self.interest_arrears is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterest-arrears>%s</%sinterest-arrears>%s' % (namespace_, self.gds_format_float(self.interest_arrears, input_name='interest-arrears'), namespace_, eol_))
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='loan-statusType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            showIndent(outfile, level)
            outfile.write('currency="%s",\n' % (self.currency,))
        if self.value_date is not None and 'value_date' not in already_processed:
            already_processed.add('value_date')
            showIndent(outfile, level)
            outfile.write('value-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.value_date, input_name='value-date'))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            showIndent(outfile, level)
            outfile.write('year=%f,\n' % (self.year,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.interest_received is not None:
            showIndent(outfile, level)
            outfile.write('interest_received=%f,\n' % self.interest_received)
        if self.principal_outstanding is not None:
            showIndent(outfile, level)
            outfile.write('principal_outstanding=%f,\n' % self.principal_outstanding)
        if self.principal_arrears is not None:
            showIndent(outfile, level)
            outfile.write('principal_arrears=%f,\n' % self.principal_arrears)
        if self.interest_arrears is not None:
            showIndent(outfile, level)
            outfile.write('interest_arrears=%f,\n' % self.interest_arrears)
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            self.currency = value
        value = find_attr_value_('value-date', node)
        if value is not None and 'value-date' not in already_processed:
            already_processed.add('value-date')
            try:
                self.value_date = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (value-date): %s' % exp)
        value = find_attr_value_('year', node)
        if value is not None and 'year' not in already_processed:
            already_processed.add('year')
            try:
                self.year = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (year): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'interest-received':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'interest_received')
            self.interest_received = fval_
        elif nodeName_ == 'principal-outstanding':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'principal_outstanding')
            self.principal_outstanding = fval_
        elif nodeName_ == 'principal-arrears':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'principal_arrears')
            self.principal_arrears = fval_
        elif nodeName_ == 'interest-arrears':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'interest_arrears')
            self.interest_arrears = fval_
        else:
            obj_ = self.gds_build_any(child_, 'loan-statusType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class loan_statusType


class forecastType(GeneratedsSuper):
    """The calendar year that the forward spend covers"""
    subclass = None
    superclass = None
    def __init__(self, currency=None, value_date=None, year=None, valueOf_=None):
        self.original_tagname_ = None
        self.currency = _cast(None, currency)
        if isinstance(value_date, basestring):
            initvalue_ = datetime_.datetime.strptime(value_date, '%Y-%m-%d').date()
        else:
            initvalue_ = value_date
        self.value_date = initvalue_
        self.year = _cast(float, year)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if forecastType.subclass:
            return forecastType.subclass(*args_, **kwargs_)
        else:
            return forecastType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_value_date(self): return self.value_date
    def set_value_date(self, value_date): self.value_date = value_date
    def get_year(self): return self.year
    def set_year(self, year): self.year = year
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='forecastType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='forecastType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='forecastType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='forecastType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            outfile.write(' currency=%s' % (self.gds_format_string(quote_attrib(self.currency).encode(ExternalEncoding), input_name='currency'), ))
        if self.value_date is not None and 'value_date' not in already_processed:
            already_processed.add('value_date')
            outfile.write(' value-date="%s"' % self.gds_format_date(self.value_date, input_name='value-date'))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            outfile.write(' year="%s"' % self.gds_format_float(self.year, input_name='year'))
    def exportChildren(self, outfile, level, namespace_='', name_='forecastType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='forecastType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            showIndent(outfile, level)
            outfile.write('currency="%s",\n' % (self.currency,))
        if self.value_date is not None and 'value_date' not in already_processed:
            already_processed.add('value_date')
            showIndent(outfile, level)
            outfile.write('value-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.value_date, input_name='value-date'))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            showIndent(outfile, level)
            outfile.write('year=%f,\n' % (self.year,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            self.currency = value
        value = find_attr_value_('value-date', node)
        if value is not None and 'value-date' not in already_processed:
            already_processed.add('value-date')
            try:
                self.value_date = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (value-date): %s' % exp)
        value = find_attr_value_('year', node)
        if value is not None and 'year' not in already_processed:
            already_processed.add('year')
            try:
                self.year = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (year): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class forecastType


class categoryType(GeneratedsSuper):
    """An IATI code defining the category of the document."""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if categoryType.subclass:
            return categoryType.subclass(*args_, **kwargs_)
        else:
            return categoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='categoryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='categoryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='categoryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='categoryType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='categoryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='categoryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'categoryType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class categoryType


class languageType(GeneratedsSuper):
    """ISO 639-1 language code"""
    subclass = None
    superclass = None
    def __init__(self, code=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if languageType.subclass:
            return languageType.subclass(*args_, **kwargs_)
        else:
            return languageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='languageType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='languageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='languageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='languageType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='languageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='languageType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'languageType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class languageType


GDSClassesMapping = {
    'sector': sectorType,
    'comment': textRequiredType,
    'person-name': textRequiredType,
    'point': pointType,
    'recipient-country': recipient_countryType,
    'repayment-plan': repayment_planType,
    'budget-item': budget_itemType,
    'repayment-first-date': repayment_first_dateType,
    'period-start': period_startType,
    'transaction-date': transaction_dateType,
    'location-id': location_idType,
    'finance-type': finance_typeType,
    'loan-terms': loan_termsType,
    'category': categoryType,
    'indicator': indicatorType,
    'aid-type': aid_typeType,
    'baseline': baselineType,
    'receiver-org': receiver_orgType,
    'title': textRequiredType,
    'period-end': period_endType,
    'organisation': textRequiredType,
    'loan-status': loan_statusType,
    'transaction-type': transaction_typeType,
    'location-class': location_classType,
    'repayment-type': repayment_typeType,
    'activity-description': textRequiredType,
    'department': textRequiredType,
    'administrative': administrativeType,
    'email': emailType,
    'website': websiteType,
    'flow-type': flow_typeType,
    'description': textRequiredType,
    'repayment-final-date': repayment_final_dateType,
    'disbursement-channel': disbursement_channelType,
    'telephone': telephoneType,
    'language': languageType,
    'location-reach': location_reachType,
    'commitment-date': commitment_dateType,
    'job-title': textRequiredType,
    'condition': conditionType,
    'target': targetType,
    'mailing-address': textRequiredType,
    'actual': actualType,
    'name': textRequiredType,
    'provider-org': provider_orgType,
    'other-flags': other_flagsType,
    'forecast': forecastType,
    'value': currencyType,
    'exactness': exactnessType,
    'tied-status': tied_statusType,
    'period': periodType,
    'recipient-region': recipient_regionType,
    'feature-designation': feature_designationType,
    'owner-org': owner_orgType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=True):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'iati_activities'
        rootClass = iati_activities
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'iati_activities'
        rootClass = iati_activities
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'iati_activities'
        rootClass = iati_activities
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'iati_activities'
        rootClass = iati_activities
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from iati import *\n\n')
        sys.stdout.write('import iati as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "activity_date",
    "activity_scope",
    "activity_status",
    "actualType",
    "administrativeType",
    "aid_typeType",
    "baselineType",
    "budget",
    "budget_itemType",
    "capital_spend",
    "categoryType",
    "collaboration_type",
    "commitment_dateType",
    "conditionType",
    "conditions",
    "contact_info",
    "country_budget_items",
    "crs_add",
    "currencyType",
    "default_aid_type",
    "default_finance_type",
    "default_flow_type",
    "default_tied_status",
    "description",
    "descriptionType",
    "disbursement_channelType",
    "document_link",
    "emailType",
    "exactnessType",
    "feature_designationType",
    "finance_typeType",
    "flow_typeType",
    "forecastType",
    "fss",
    "iati_activities",
    "iati_activity",
    "iati_identifier",
    "indicatorType",
    "languageType",
    "legacy_data",
    "loan_statusType",
    "loan_termsType",
    "location",
    "location_classType",
    "location_idType",
    "location_reachType",
    "narrative",
    "other_flagsType",
    "other_identifier",
    "owner_orgType",
    "participating_org",
    "periodType",
    "period_endType",
    "period_endType2",
    "period_endType4",
    "period_startType",
    "period_startType1",
    "period_startType3",
    "planned_disbursement",
    "pointType",
    "policy_marker",
    "provider_orgType",
    "receiver_orgType",
    "recipient_country",
    "recipient_countryType",
    "recipient_region",
    "recipient_regionType",
    "related_activity",
    "repayment_final_dateType",
    "repayment_first_dateType",
    "repayment_planType",
    "repayment_typeType",
    "reporting_org",
    "result",
    "sector",
    "sectorType",
    "targetType",
    "telephoneType",
    "textRequiredType",
    "textType",
    "tied_statusType",
    "transaction",
    "transaction_dateType",
    "transaction_typeType",
    "websiteType"
]
